PRO DECODE_GRIB2_RECORD, GRIBFilePath, $
                         scratchDir, $
                         fieldPattern, $
                         record, $
                         verificationTime, $
                         level, $
                         fcstTimeRange, $
                         varAbbreviation, $
                         varField, $
                         varUnits, $
                         numColumns, $
                         numRows, $
                         data, $
                         NO_DATA_VALUE = ndv

;+
; Decode a record from a GRIB version 2 file.
;
; :Params:
;     GRIBFilePath : in, required, type=STRING
;         The GRIB2 file path. Files that have gzip extensions will be
;         identified and unzipped non-disruptively prior to decoding.
;     scratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure are stored.
;     fieldPattern : in, required, type=STRING
;         A string that can be used to identify a unique (hopefully)
;         GRIB2 record. This pattern is used with the wgrib2 "-match"
;         command during decoding.
;     record : out, type=STRING
;         The GRIB record number.
;     verificationTime : out, type=STRING
;         The GRIB record verification time.
;     level : out, type=STRING
;         The GRIB record level.
;     fcstTimeRange : out, type=STRING
;         The GRIB record forecast time range.
;     varAbbreviation : out, type=STRING
;         The abbreviation for the record.
;     varField : out, type=STRING
;         The field name corresponding to varAbbreviation.
;     varUnits : out, type=STRING
;         The units for the data in the GRIB record.
;     numColumns : out, type=LONG
;         The number of columns in the GRIB record data.
;     numRows : out, type=LONG
;         The number of rows in the GRIB record data.
;     data : out, type=LONG
;         The 2-D array of GRIB record data.
;
; :Keywords:
;     NO_DATA_VALUE : in, type=FLOAT
;         The value to use for missing data in the GRIB record
;         data. The value stored in the GRIB record itself will be
;         9.999e20, and all cells having this value will be changed to
;         the NO_DATA_VALUE setting.
;-

;+
; Initialize output grid to !NULL. The caller should use
; ISA(MRMSWtGrid) to judge the success/failure of this procedure.
;-
  data = !NULL

;+
; TODO: check all arguments for validity.
;-
  if NOT(FILE_TEST(GRIBFilePath)) then begin
      ERR_MSG, 'File "' + GRIBFilePath + '" not found.'
      RETURN
  endif

;+
; Deal with zipped files. If the GRIBFilePath ends with one of the
; extensions below, this procedure will attempt to use the gzip
; utility to decompress a copy of the file before reading it.
;-
  GRIBFile = FILE_BASENAME(GRIBFilePath)

  gz1Pos = STRPOS(GRIBFile, '.gz', 2, /REVERSE_SEARCH, /REVERSE_OFFSET)
  gz2pos = STRPOS(GRIBFile, '-gz', 2, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z1Pos = STRPOS(GRIBFile, '.z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z2Pos = STRPOS(GRIBFile, '-z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z3Pos = STRPOS(GRIBFile, '_z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z4Pos = STRPOS(GRIBFile, '.Z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  zipPos = [gz1Pos, gz2Pos, z1Pos, z2Pos, z3Pos, z4Pos]
  ind = WHERE(zipPos ne -1, count)
  if (count eq 1) then begin

;+
;     Verify the file is not empty.
;-
      if FILE_TEST(GRIBFilePath, /ZERO_LENGTH) then begin
          ERR_MSG, GRIBFilePath + ' is an empty file.'
          RETURN
      endif

;+
;     Copy the file to the scratchDir.
;-
      cmd = 'cp --preserve=mode,timestamps ' + $
            GRIBFilePath + ' ' + scratchDir
      SPAWN, cmd, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Failed to copy ' + GRIBFilePath + ' to ' + scratchDir
          RETURN
      endif
      if NOT(FILE_TEST(scratchDir + '/' + GRIBFile)) then begin
          ERR_MSG, 'File copy ' + scratchDir + '/' + GRIBFile + $
                   ' not found.'
          RETURN
      endif

      ind = ind[0]
      cmd = 'gzip -d ' + scratchDir + '/' + GRIBFile
      SPAWN, cmd, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Command "' + cmd + '" failed.'
          RETURN
      endif
      tmpGRIBFile = STRMID(GRIBFile, 0, zipPos[ind])
      if NOT(FILE_TEST(scratchDir + '/' + tmpGRIBFile)) then begin
          ERR_MSG, 'Output file missing after command "gzip -d ' + $
                   scratchDir + '/' + GRIBFile + '".'
          RETURN
      endif

      inputPath = scratchDir + '/' + tmpGRIBFile

  endif else begin

      tmpGRIBFile = GRIBFile
      inputPath = GRIBFilePath

  endelse

;+
; Generate a (probably) unique temporary file name for decoded data
; using the date and process ID.
;-
  SPAWN, 'date -u +%Y%m%d%H%M%S', dateStr
  dateStr = dateStr[0]
  pidStr = STRCRA(GETPID())
  tmpGRIBRaster = scratchDir + '/tmpGRIBRaster.' + dateStr + '.' + pidStr
;  tmpGRIBHeader = scratchDir + '/tmpGRIBHeader.' + dateStr + '.' + pidStr

;+
; Decode the GRIB record, storing results in a header string and data
; file.
; wgrib option -V = -vt -lev -ftime -var -ens -stats -grid
;-
  cmd = 'wgrib2 -g2clib 0 -V -end -order we:sn -match "' + $
        fieldPattern + '" ' + inputPath + $
        ' -bin ' + tmpGRIBRaster ; + ' > ' + tmpGRIBHeader
  SPAWN, cmd, hdr, EXIT_STATUS = status
  if (status ne 0) then begin
      ERR_MSG, 'Command "' + cmd + '" failed.'
      RETURN
  endif

;+
; Delete the temporary copy if gzip was used.
;-
  if (inputPath eq scratchDir + '/' + tmpGRIBFile) then $
      FILE_DELETE, inputPath

;+
; Verify the output header is the expected size.'
;-
  if (N_ELEMENTS(hdr) lt 4) then begin
      ERR_MSG, 'Invalid output header (at least 4 elements expected, ' + $
               'found ' + STRCRA(N_ELEMENTS(hdr)) + ')'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

;+
; Check the data file size.  The wgrib2 program does not necessarily
; give a nonzero exit status when it fails.
;-
  ;; hInfo = FILE_INFO(tmpGRIBHeader)
  ;; if (hInfo.size eq 0L) then begin
  ;;     ERR_MSG, 'FATAL: wgrib2 produced an empty header file.'
  ;;     RETURN
  ;; endif

  rInfo = FILE_INFO(tmpGRIBRaster)
  if (rInfo.size eq 0L) then begin
      ERR_MSG, 'FATAL: wgrib2 produced an empty raster file.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

;+
; Read the GRIB2 header.
;-

;+
; First line:  inventory.
;-
  inventory = hdr[0]

;+
; Record number.
;-
  recPos = 0
  colonPos = STRPOS(inventory, ':', recPos)
  if (colonPos eq -1) then begin
      ERR_MSG, 'FATAL: unknown record format in GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  record = STRMID(inventory, recPos, colonPos - recPos)

;+
; Byte position (not used).
;-
  next = STRPOS(inventory, ':', colonPos + 1)
  if (next eq -1) then begin
      ERR_MSG, 'FATAL: unknown byte position format in GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  startByte = STRMID(inventory, colonPos + 1, next - colonPos - 1)

;+
; Verification time (-vt)
;-
  vtPos = STRPOS(inventory, 'vt=', next + 1)
  if (vtPos eq -1) then begin
      ERR_MSG, 'FATAL: valid time not found in GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  next = STRPOS(inventory, ':', vtPos + 3)
  if (next eq -1) then begin
      ERR_MSG, 'FATAL: unknown date format in GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  if (next - vtPos ne 13) then begin
      ERR_MSG, 'FATAL: unknown date format "' + $
               STRMID(inventory, vtPos + 3, next - vtPos - 3) + '".'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  verificationTime = STRMID(inventory, vtPos + 3, 10)

;+
; Level (-lev)
;-
  c1Pos = next
  c2Pos = STRPOS(inventory, ':', c1Pos + 1)
  if (c2Pos eq -1) then begin
      ERR_MSG, 'FATAL: incomplete level description in GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  level = STRMID(inventory, c1Pos + 1, c2Pos - c1Pos - 1)

;+
; Forecast Time range (-ftime)
;-
  c1Pos = c2Pos
  next = STRPOS(inventory, ':', c1Pos + 1)
  if (next eq -1) then begin
      ERR_MSG, 'FATAL: incomplete forecast time description in ' + $
               'GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  fcstTimeRange = STRMID(inventory, c1Pos + 1, next - c1Pos - 1)

;+
; Field varAbbreviation (-var)
;-
  abbrevPos = next + 1
  next = STRPOS(inventory, ' ', abbrevPos)
  if (next eq -1) then begin
      ERR_MSG, 'FATAL: missing field abbreviation in GRIB inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  varAbbreviation = STRMID(inventory, abbrevPos, next - abbrevPos)

;+
; Field (add-on to -var)
;-
  fieldPos = next + 1
  next = STRPOS(inventory, ' [', fieldPos)
  if (next eq -1) then begin    ; no units given

      next = STRPOS(inventory, ':', fieldPos)
      if (next eq -1) then begin
          ERR_MSG, 'FATAL: missing field description in GRIB inventory.'
          FILE_DELETE, tmpGRIBRaster, /QUIET
          RETURN
      endif
      varField = STRMID(inventory, fieldPos, next - fieldPos)
      varUnits = ''

  endif else begin

      varField = STRMID(inventory, fieldPos, next - fieldPos)

;+
;     VarUnits (add-on to -var)
;-
      br1Pos = STRPOS(inventory, '[', next + 1)
      if (br1Pos eq -1) then begin
          ERR_MSG, 'FATAL: missing units in GRIB inventory.'
          FILE_DELETE, tmpGRIBRaster, /QUIET
          RETURN
      endif
      br2Pos = STRPOS(inventory, ']', br1Pos)
      if (br2Pos eq -1) then begin
          ERR_MSG, $
              'FATAL: unknown format for data units in GRIB inventory.'
          FILE_DELETE, tmpGRIBRaster, /QUIET
          RETURN
      endif
      varUnits = STRMID(inventory, br1Pos + 1, br2Pos - br1Pos - 1)

  endelse

;+
; Ignore second and third lines.
;-

;+
; Fourth line: general grid information
;-
  inventory = hdr[3]

;+
; Get grid dimensions.
;-
  if NOT(STREGEX(inventory, '\([0-9]+ x [0-9]+\)', /BOOLEAN)) $
  then begin
      ERR_MSG, 'FATAL: failed to get grid dimensions from GRIB ' + $
               'inventory.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

  dims = STREGEX(inventory, '\([0-9]+ x [0-9]+\)', /EXTRACT)

  nxStr = STREGEX(dims, '\([0-9]+ x', /EXTRACT)
  numColumns = LONG(STRMID(nxStr, 1, STRLEN(nxStr) - 3))

  nyStr = STREGEX(dims, 'x [0-9]+\)', /EXTRACT)
  numRows = LONG(STRMID(nyStr, 2, STRLEN(nyStr) - 3))

;+
; Read the grid.
;-
  OPENU, lun, tmpGRIBRaster, /GET_LUN

  gridSizeBytes = 0L
  READU, lun, gridSizeBytes ; rows * columns * sizeof(float)

  if (gridSizeBytes ne (numColumns * numRows * 4L)) then begin
      ERR_MSG, 'FATAL: unexpected grid size read from GRIB binary output.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

  data_ = FLTARR(numColumns, numRows)
  READU, lun, data_

  FREE_LUN, lun
  FILE_DELETE, tmpGRIBRaster

;+
; Apply the no-data value.
;-
  if (KEYWORD_SET(ndv)) then begin
      if (ndv eq 1) then begin
          ERR_MSG, 'WARNING: NO_DATA_VALUE keyword should be explicitly ' + $
                   'assigned a value.'
          ndv = 9.999e20
      endif
      index = WHERE(data_ eq 9.999e20, count)
      if (count gt 0) then begin
          data_[index] = ndv
      endif
  endif

  data = TEMPORARY(data_)

  RETURN

end
