PRO GET_HOURLY_HRRR_LC_APCP_WEASD, $
    HourEndDate_YYYYMMDDHH, $ ; accumulation end date/time
    TargetFcstHour, $         ; target forecast hour, usually 3
    MinSubFcstHour, $         ; minimum substitute forecast hour, usually 1
    MaxSubFcstHour, $         ; maximum substitute forecast hour, usually 6
    HRRRDir, $                ; location of HRRR archive
    ScratchDir, $             ; location for temporary/cache files
    NoDataValue, $            ; no data value
    WEASDGrid, $
    APCPGrid, $
    perfect, $
    HRRR_GRID_PROJ_INFO = HRRRGridProjInfo, $
    FORECAST_HOUR_FOUND = fcstHourFound, $
    DRY_RUN_STATUS = dryRunStatus, $
    VERBOSE = Verbose, $
    NO_SAVE_FILE = No_save_file
;+
; Get hourly High Resolution Rapid Refresh (HRRR) total precipitation
; (APCP) and water equivalent of accumulated snow depth (WEASD).
;
; There are different conventions for storing/archiving HRRR data that
; this procedure will need to handle. In the case of long-term
; archives, data are stored in directories such as:
;
;   /nwcdev/archive/HRRR_archive/{YYYY}/{MM}/{DD}
;
; In the case of GRIB files handled by operations, data are stored in
; a place like
;
;   /operations/misc/gisrs_incoming/HRRR
;
; In all cases we assume the GRIB files have names following one of
; these conventions:
;
;   {YY}{DOY}.hrrr.t{HH}z.wrfsfcff{FF}.grib2
;   hrrr.{YYYYMMDD}.t{HH}z.wrfsfcf{FF}.grib2
;
; :Params:
;
;     HourEndDate_YYYYMMDDHH : in, required, type=STRING
;         End time of hourly accumulation period in UTC, in the form
;         YYYYMMDDHH.
;     TargetFcstHour : in, required, type=INT
;         The forecast hour that is sought for all QPF data.
;     MinSubFcstHour : in, required, type=INT
;         The minimum forecast hour to substitute in place of
;         TargetFcstHour, if QPF for TargetFcstHour is unavailable.
;     MaxSubFcstHour : in, required, type=INT
;         The maximum forecast hour to substitute in place of
;         TargetFcstHour, if QPF for TargetFcstHour is unavailable.
;     HRRRDir : in, required, type=STRING
;         The directory where High Resolution Rapid Refresh (HRRR)
;         quantitative precipitation forecasts (QPF) are stored.
;     ScratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure and the procedures it calls are stored.
;     NoDataValue : in, required, type=FLOAT
;         The value to use for missing/no-data on all grids. Missing
;         values for input data (e.g., 9.999e20 on GRIB data produced
;         at NCEP) are replaced by this value, and missing/no-data is
;         set to this value for all outputs.
;     APCPGrid : out, type=FLTARR(1799 x 1059)
;         The decoded HRRR "total precipitation" GRIB record (which may
;         be derived by adding ACPCP ("convective precipitation") and
;         NCPCP ("large scale precipitation") records).
;     WEASDGrid : out, type=FLTARR(1799 x 1059)
;         The decoded HRRR "water equivalent of accumulated snow
;         depth" GRIB record.
;     perfect : out, type=BYTE
;         A flag that indicates whether (1) or not (0) data was found
;         for the TargetFcstHour.
;
; :Keywords:
;
;     HRRR_GRID_PROJ_INFO : type=STRUCT
;         A named variable that will capture the structure describing
;         the HRRR (Lambert conformal) grid and coordinate system. If
;         this variable is undefined, it will be defined. If it is
;         already defined, it will be verified against the contents of
;         the input GRIB2 file.
;         Structure tags:
;
;         lonV (type=DOUBLE):
;         The orientation longitude, degrees.
;
;         latD (type=DOUBLE):
;         The latitude where the grid spacing is defined, degrees.
;
;         latSec1 (type=DOUBLE):
;         The first standard parallel for the projection, degrees.
;
;         latSec2 (type=DOUBLE):
;         The second standard parallel for the projection, degrees.
;
;         eRadM (type=DOUBLE):
;         The radius of the spherical earth in the projection, meters.
;
;         lat00 (type=DOUBLE):
;         The lower left grid cell center latitude, degrees.
;
;         lon00 (type=DOUBLE):
;         The lower left grid cell center longitude, degrees.
;
;         nCols (type=LONG):
;         The number of columns in the GRIB record.
;
;         nRows (type=LONG):
;         The number of rows in the GRIB record.
;
;         dx (type=DOUBLE):
;         The grid spacing in x, meters.
;
;         dy (type=DOUBLE):
;         The grid spacing in y, meters.
;
;     FORECAST_HOUR_FOUND : out, type=INT
;         Set this to a named variable in which the forecast hour
;         located and decoded is returned.
;
;     DRY_RUN_STATUS : out, type=INT
;         To search for data and exit before reading it, set this
;         keyword to a named variable. If this argument is present,
;         the procedure will exit upon finding (or not finding) input
;         data for the hour requested. A value of 1 indicates success
;         at finding HRRR QPF, and a value of 0 indicates failure.
;
;     VERBOSE : in, type=BOOLEAN
;         Activates the "verbose" option, causing this procedure to
;         produce some extra output text.
;
;     NO_SAVE_FILE : in, type=BOOLEAN
;         Deactivates the default behavior of this procedure, which
;         stores a version of its results in the ScratchDir as an IDL
;         save file, and reads its data from a save file if one is
;         found.
;-
  COMMON info, Message ; used by USR_MSG and ERR_MSG

;+
; The best way to check for the success of this procedure is to do
; "if (NOT(ISA(WEASDGrid)) or NOT(ISA(APCPGrid)))then STOP" or
; something similar in the caller, since both will be returned as !NULL
; if this procedure hits an exception.
;-
  APCPGrid = !NULL
  WEASDGrid = !NULL

  perfect = 0B
  dryRun = 0
  if ARG_PRESENT(dryRunStatus) then dryRun = 1
  dryRunStatus = 0B

;+
; Error handler for anything the main procedure code misses. Example:
; RESTORE encounters a file that was truncated because a disk filled.
; Comment this section out when debugging.
;-
  CATCH, errorStatus
  if (errorStatus ne 0) then begin
      ERR_MSG, !Error_State.Msg
      RETURN
  endif

;+
; Check arguments for correct type and valid contents.
;-
  if NOT(ISA(HourEndDate_YYYYMMDDHH, 'STRING')) then begin
      ERR_MSG, 'Target date/time argument must be a STRING.'
      RETURN
  endif
  if (STRLEN(HourEndDate_YYYYMMDDHH) ne 10) then begin
      ERR_MSG, 'Invalid target date/time "' + $
               HourEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, 10 digits).'
      RETURN
  endif
  if NOT(STREGEX(HourEndDate_YYYYMMDDHH, '[0-9]{10}', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Invalid target date/time "' + $
               HourEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, all numeric).'
      RETURN
  endif

  if ((TargetFcstHour lt 1) or $
      (MinSubFcstHour lt 1) or $
      (MaxSubFcstHour lt 1)) then begin
      ERR_MSG, 'All forecast hour options must be greater than zero.'
      RETURN
  endif

  if (MinSubFcstHour gt MaxSubFcstHour) then begin
      ERR_MSG, 'Minimum substitute forecast hour may not be larger than ' + $
               'maximum substitute forecast hour.'
      RETURN
  endif

  if NOT(ISA(HRRRDir, 'STRING')) then begin
      ERR_MSG, 'Location of HRRR archive must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(HRRRDir, /DIRECTORY)) then begin
      ERR_MSG, 'HRRR archive directory "' + HRRRDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(HRRRDir, /READ)) then begin
      ERR_MSG, 'HRRR archive directory "' + HRRRDir + '" not readable.'
      RETURN
  endif

  if NOT(ISA(ScratchDir, 'STRING')) then begin
      ERR_MSG, 'Location of scratch directory must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /DIRECTORY)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /READ)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not readable.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /WRITE)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not writeable.'
      RETURN
  endif

  if NOT(ISA(NoDataValue, 'FLOAT')) then $
      ERR_MSG, 'WARNING: no-data value should be a floating point value.'

  if KEYWORD_SET(HRRRGridProjInfo) then begin

;+
;     Verify the structure of HRRRGridProjInfo.
;-
      sizeHRRRGridProjInfo = SIZE(HRRRGridProjInfo)
      if (sizeHRRRGridProjInfo[0] ne 1) then begin
          ERR_MSG, 'HRRR_GRID_PROJ_INFO structure mismatch (non-scalar).'
          RETURN
      endif

      if ((sizeHRRRGridProjInfo[1] ne 1) or $
          (sizeHRRRGridProjInfo[2] ne 8)) then begin
          ERR_MSG, 'HRRR_GRID_PROJ_INFO structure mismatch ' + $
                   '(not a structure).'
          RETURN
      endif

      sizeHRRRGridProjInfo = !NULL

      structOK = 1

      tagNames = TAG_NAMES(HRRRGridProjInfo)
      ind = WHERE(tagNames eq 'LONV', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lonV" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LATD', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latD" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LATSEC1', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latSec1" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LATSEC2', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latSec2" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'ERADM', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "eRadM" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LAT00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lat00" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LON00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lon00" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'NCOLS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nCols" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'NROWS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nRows" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'DX', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dx" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'DY', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dy" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      if structOK then begin

          if NOT(ISA(HRRRGridProjInfo.lonV, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"lonV".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.latD, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"latD".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.latSec1, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"latSec1".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.latSec2, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"latSec2".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.eRadM, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"eRadM".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.lat00, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"lat00".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.lon00, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"lon00".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.nCols, 'LONG')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing LONG element ' + $
                       '"nCols".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.nRows, 'LONG')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing LONG element ' + $
                       '"nRows".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.dx, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"dx".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.dy, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"dy".'
              structOK = 0
          endif

      endif

      if NOT(structOK) then begin

          ERR_MSG, 'Unexpected HRRR_GRID_PROJ_INFO structure definition.'
          RETURN

      endif

      structOK = !NULL

  endif

;+
; Identify IDL save file.
;-
  savFile = 'HRRR_APCP_WEASD' + $
            '_f' + STRING(TargetFcstHour, FORMAT = '(I2.2)') + $
            '_' + HourEndDate_YYYYMMDDHH + '.sav'

  if (NOT(KEYWORD_SET(No_save_file)) and $
      (FILE_TEST(ScratchDir + '/' + savFile))) then begin

;+
;     Get data from cache file rather than reading HRRR data
;     directly.
;-
      if KEYWORD_SET(Verbose) then $
          USR_MSG, 'Reading ' + ScratchDir + '/' + savFile

      RESTORE, ScratchDir + '/' + savFile

;+
;     Verify the contents of the save file.
;-
      if NOT(ISA(WEASDGrid)) then begin
          ERR_MSG, 'No WEASD grid variable in ' + $
                   ScratchDir + '/' + savFile
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      gridSize = SIZE(WEASDGrid)
      if (gridSize[0] ne 2) then begin
          ERR_MSG, 'WEASD grid in ' + ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      nCols = gridSize[1]
      nRows = gridSize[2]

      if NOT(ISA(APCPGrid)) then begin
          ERR_MSG, 'No "APCPGrid" variable in ' + $
                   ScratchDir + '/' + savFile
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      gridSize = SIZE(APCPGrid)
      if (gridSize[0] ne 2) then begin
          ERR_MSG, '"APCPGrid" in ' + ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      if (gridSize[1] ne nCols) then begin
          ERR_MSG, '"APCPGrid" column dimension (' + $
                   STRCRA(gridSize[1]) + ') ' + $
                   'does not match that of "WEASDGrid" (' + STRCRA(nCols) + $
                   ').'
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      if (gridSize[2] ne nRows) then begin
          ERR_MSG, '"APCPGrid" row dimension (' + STRCRA(gridSize[2]) + ') ' + $
                   'does not match that of "WEASDGrid" (' + STRCRA(nRows) + $
                   ').'
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      gridSize = !NULL

      if NOT(ISA(ndv_)) then begin
          ERR_MSG, 'Missing "ndv_" variable in ' + $
                   ScratchDir + '/' + savFile
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      if NOT(ISA(HRRRGridProjInfo_)) then begin
          ERR_MSG, 'No HRRR grid/projection info structure in ' + $
                   ScratchDir + '/' + savFile
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif


;     Verify the structure of HRRRGridProjInfo_ and grid dimensions.

      foo = SIZE(HRRRGridProjInfo_)
      if (foo[0] ne 1) then begin
          ERR_MSG, 'HRRRGridProjInfo_ structure mismatch (non-scalar) ' + $
                   'in ' + ScratchDir + '/' + savFile
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      if ((foo[1] ne 1) or (foo[2] ne 8)) then begin
          ERR_MSG, 'HRRRGridProjInfo_ structure mismatch ' + $
                   '(not a structure) ' + $
                   'in ' + ScratchDir + '/' + savFile
          WEASDGrid = !NULL
          APCPGrid = !NULL
          RETURN
      endif

      savFileOK = 1

      tagNames = TAG_NAMES(HRRRGridProjInfo_)
      ind = WHERE(tagNames eq 'LONV', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lonV" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LATD', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latD" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LATSEC1', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latSec1" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LATSEC2', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latSec2" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'ERADM', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "eRadM" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LAT00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lat00" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LON00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lon00" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'NCOLS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nCols" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'NROWS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nRows" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'DX', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dx" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'DY', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dy" tag in "HRRRGridProjInfo_" from ' + $
                   'IDL save file ' + ScratchDir + '/' + savFile
          savFileOK = 0
      endif

      if savFileOK then begin

          if NOT(ISA(HRRRGridProjInfo_.lonV, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"lonV" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.latD, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"latD" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.latSec1, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"latSec1" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.latSec2, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"latSec2" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.eRadM, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"eRadM" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.lat00, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"lat00" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.lon00, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"lon00" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.nCols, 'LONG')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing LONG element ' + $
                       '"nCols" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif else begin
              if (nCols ne HRRRGridProjInfo_.nCols) then begin
                  ERR_MSG, 'Grid columns in ' + $
                           ScratchDir + '/' + savFile + $
                           ' (' + STRCRA(nCols) + ') ' + $
                           'do not match "HRRRGridProjInfo_" value ' + $
                           '(' + STRCRA(HRRRGridProjInfo_.nCols) + ').'
                  savFileOK = 0
              endif
          endelse

          if NOT(ISA(HRRRGridProjInfo_.nRows, 'LONG')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing LONG element ' + $
                       '"nRows" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif else begin
              if (nRows ne HRRRGridProjInfo_.nRows) then begin
                  ERR_MSG, 'Grid rows in ' + $
                           ScratchDir + '/' + savFile + $
                           ' (' + STRCRA(nRows) + ') ' + $
                           'do not match "HRRRGridProjInfo_" value ' + $
                           '(' + STRCRA(HRRRGridProjInfo_.nRows) + ').'
                  savFileOK = 0
              endif
          endelse

          if NOT(ISA(HRRRGridProjInfo_.dx, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"dx" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo_.dy, 'DOUBLE')) then begin
              ERR_MSG, '"HRRRGridProjInfo_" missing DOUBLE element ' + $
                       '"dy" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

      endif

      if (savFileOK and KEYWORD_SET(HRRRGridProjInfo)) then begin

;+
;         Verify HRRRGridProjInfo structure from caller against
;         HRRRGridProjInfo_ structure from save file.
;-
          if NOT(COMPARE(HRRRGridProjInfo.lonV, HRRRGridProjInfo_.lonV)) $
          then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "lonV" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(HRRRGridProjInfo.latD, HRRRGridProjInfo_.latD)) $
              then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "latD" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(HRRRGridProjInfo.latSec1, $
                         HRRRGridProjInfo_.latSec1)) $
              then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "latSec1" ' + $
                       'mismatch between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(HRRRGridProjInfo.latSec2, $
                         HRRRGridProjInfo_.latSec2)) $
              then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "latSec2" ' + $
                       'mismatch between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(HRRRGridProjInfo.eRadM, $
                         HRRRGridProjInfo_.eRadM)) $
              then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "eRadM" ' + $
                       'mismatch between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

;+
;         The "lat00" and "lon00" coordinates for the HRRR grid
;         changed on 2016-08-23 14Z, when HRRR version 2 went into
;         operations. In GRIB files these read as "Lat1" and "Lon1"
;         and changed from 21.138000 and 237.280000 to 21.138123 and
;         237.280472.
;-
          if NOT(COMPARE(HRRRGridProjInfo.lat00, HRRRGridProjInfo_.lat00)) $
              then begin

              if ((HRRRGridProjInfo.lat00 ne 21.138000D) and $
                  (HRRRGridProjInfo.lat00 ne 21.138123D) and $
                  (HRRRGridProjInfo_.lat00 ne 21.138000D) and $
                  (HRRRGridProjInfo_.lat00 ne 21.138123D)) then begin

                  ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "lat00" mismatch ' + $
                           'between keyword and ' + $
                           ScratchDir + '/' + savFile + ' data.'
                  savFileOK = 0

              endif ;else begin

;+
;                 Update the structure to match the SAVE file.
;-
;                  HRRRGridProjInfo.lat00 = HRRRGridProjInfo_.lat00

;              endelse

          endif

          if NOT(COMPARE(HRRRGridProjInfo.lon00, HRRRGridProjInfo_.lon00)) $
              then begin

              if ((HRRRGridProjInfo.lon00 ne -122.720000D) and $
                  (HRRRGridProjInfo.lon00 ne -122.719528D) and $
                  (HRRRGridProjInfo_.lon00 ne -122.720000D) and $
                  (HRRRGridProjInfo_.lon00 ne -122.719528D)) then begin

                  ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "lon00" mismatch ' + $
                           'between keyword and ' + $
                           ScratchDir + '/' + savFile + ' data.'
                  savFileOK = 0

              endif ;else begin

;+
;                 Update the structure to match the SAVE file.
;-
;                  HRRRGridProjInfo.lon00 = HRRRGridProjInfo_.lon00

;          endelse

          endif

          if (HRRRGridProjInfo.nCols ne HRRRGridProjInfo_.nCols) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "nCols" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if (HRRRGridProjInfo.nRows ne HRRRGridProjInfo_.nRows) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "nRows" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(HRRRGridProjInfo.dx, HRRRGridProjInfo_.dx)) $
              then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "dx" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(HRRRGridProjInfo.dy, HRRRGridProjInfo_.dy)) $
              then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO structure "dy" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

      endif

      if (savFileOK and NOT(KEYWORD_SET(HRRRGridProjInfo))) then begin

;+
;         Copy HRRRGridProjInfo structure from save file.
;-
          HRRRGridProjInfo = HRRRGridProjInfo_

      endif

      if NOT(savFileOK) then begin

          ERR_MSG, 'Unexpected structure/content in IDL save file ' + $
                   savFile + '; returning NULL grids.'
          APCPGrid = !NULL
          WEASDGrid = !NULL
          RETURN

      endif

;+
;     Verify the no-data value is consistent; modify if it is not.
;-
      if (ndv_ ne NoDataValue) then begin
          ERR_MSG, 'WARNING: value of "ndv_" variable in ' + $
                  ScratchDir + '/' + savFile + $
                  ' (' + STRCRA(ndv_) + ') differs from ' + $
                  ' argument "NoDataValue" ' + $
                  '(' + STRCRA(NoDataValue) + '). Will adapt.'
          ind = WHERE(WEASDGrid eq ndv_, count)
          if (count gt 0) then WEASDGrid[ind] = NoDataValue
          ind = WHERE(APCPGrid eq ndv_, count)
          if (count gt 0) then APCPGrid[ind] = NoDataValue
          ind = !NULL
      endif

;+
;     Force specific "lat00" and "lon00" values from HRRR v2 and
;     above. These will even be applied to data from before
;     2016-08-23 14Z (when HRRR v2 went into operations).
;-
      HRRRGridProjInfo.lat00 = 21.138123D
      HRRRGridProjInfo.lon00 = -122.719528D

      perfect = 1B
      fcstHourFound = TargetFcstHour ; save file would not have been
                                     ; made otherwise

      RETURN

  endif

;+
; Read HRRR data from GRIB file. This is really the beginning of the
; process if we do not have a SAVE file.
;-
  perfect_ = 1B ; local flag to indicate that we got our first choice.

  hourEndDate_Julian = YYYYMMDDHH_TO_JULIAN(HourEndDate_YYYYMMDDHH)

  cycleDate_Julian = hourEndDate_Julian - $
                     DOUBLE(TargetFcstHour) / 24.0D
  cycleDate_YYYYMMDDHH = JULIAN_TO_YYYYMMDDHH(cycleDate_Julian)
  cycleDate_YYYY = STRMID(cycleDate_YYYYMMDDHH, 0, 4)
  cycleDate_MM = STRMID(cycleDate_YYYYMMDDHH, 4, 2)
  cycleDate_DD = STRMID(cycleDate_YYYYMMDDHH, 6, 2)

  fcstHourFound_ = TargetFcstHour

  ;; if KEYWORD_SET(No_subdirs) then $
  ;;     GRIBDir = HRRRDir $
  ;; else $
  ;;     GRIBDir = HRRRDir + $
  ;;               '/' + cycleDate_YYYY + $
  ;;               '/' + cycleDate_MM + $
  ;;               '/' + cycleDate_DD

  GRIBDir_noSubdirs = HRRRDir

  GRIBDir_subdirs = HRRRDir + $
                    '/' + cycleDate_YYYY + $
                    '/' + cycleDate_MM + $
                    '/' + cycleDate_DD

  ;; if KEYWORD_SET(Use_YYDOY) then begin

  ;;     cycleDate_YY = STRMID(cycleDate_YYYY, 2, 2)
  ;;     Jan1_Julian = YYYYMMDDHH_TO_JULIAN(cycleDate_YYYY + '010100')
  ;;     dayOfYear = FIX(cycleDate_Julian - Jan1_Julian) + 1
  ;;     cycleDate_DOY = STRING(dayOfYear, FORMAT = '(I3.3)')

  ;;     GRIBFile = cycleDate_YY + cycleDate_DOY + $
  ;;                '.hrrr.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
  ;;                'z.wrfsfcf' + $
  ;;                STRING(TargetFcstHour, FORMAT = '(I2.2)') + $
  ;;                '.grib2'

  ;; endif else begin

  ;;     GRIBFile = 'hrrr.' + $
  ;;                STRMID(cycleDate_YYYYMMDDHH, 0, 8) + $
  ;;                '.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
  ;;                'z.wrfsfcf' + $
  ;;                STRING(TargetFcstHour, FORMAT = '(I2.2)') + $
  ;;                '.grib2'
  ;; endelse

  cycleDate_YY = STRMID(cycleDate_YYYY, 2, 2)
  Jan1_Julian = YYYYMMDDHH_TO_JULIAN(cycleDate_YYYY + '010100')
  dayOfYear = FIX(cycleDate_Julian - Jan1_Julian) + 1
  cycleDate_DOY = STRING(dayOfYear, FORMAT = '(I3.3)')

  GRIBFile_YYDOY = cycleDate_YY + cycleDate_DOY + $
                   '.hrrr.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
                   'z.wrfsfcf' + $
                   STRING(TargetFcstHour, FORMAT = '(I2.2)') + $
                   '.grib2'

  GRIBFile_YYYYMMDD = 'hrrr.' + $
                      STRMID(cycleDate_YYYYMMDDHH, 0, 8) + $
                      '.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
                      'z.wrfsfcf' + $
                      STRING(TargetFcstHour, FORMAT = '(I2.2)') + $
                      '.grib2'

  GRIBDir = ''
  GRIBFile = ''

  if FILE_TEST(GRIBDir_subdirs, /DIRECTORY) then begin

      case 1 of

          FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_YYDOY) : begin
              GRIBDir = GRIBDir_subdirs
              GRIBFile = GRIBFile_YYDOY
          end

          FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_YYYYMMDD) : begin
              GRIBDir = GRIBDir_subdirs
              GRIBFile = GRIBFile_YYYYMMDD
          end

          else : begin
              GRIBDir = ''
              GRIBFile = ''
          end

      endcase

  endif

  ;; if ((GRIBDir eq '') and (GRIBFile eq '')) then $
  ;;   USR_MSG, '01 HRRR QPF not found in ' + $
  ;;            GRIBDir_subdirs + '/' + GRIBFile_YYDOY + $
  ;;            ' or ' + $
  ;;            GRIBDIR_subdirs + '/' + GRIBFile_YYYYMMDD

  if (FILE_TEST(GRIBDir_noSubdirs) and $
      ((GRIBDir eq '') or (GRIBFile eq ''))) then begin

      case 1 of

          FILE_TEST(GRIBDir_noSubdirs + '/' + GRIBFile_YYDOY) : begin
              GRIBDir = GRIBDir_noSubdirs
              GRIBFile = GRIBFile_YYDOY
          end

          FILE_TEST(GRIBDir_noSubdirs + '/' + GRIBFile_YYYYMMDD) : begin
              GRIBDir = GRIBDir_noSubdirs
              GRIBFile = GRIBFile_YYYYMMDD
          end

          else : begin
              GRIBDir = ''
              GRIBFile = ''
          end

      endcase

  endif

  ;; if ((GRIBDir eq '') and (GRIBFile eq '')) then $
  ;;   USR_MSG, '02 HRRR QPF not found in ' + $
  ;;            GRIBDir_noSubdirs + '/' + GRIBFile_YYDOY + $
  ;;            ' or ' + $
  ;;            GRIBDIR_noSubdirs + '/' + GRIBFile_YYYYMMDD

  if ((GRIBDir eq '') or (GRIBFile eq '') or $
      NOT(FILE_TEST(GRIBDir + '/' + GRIBFile))) then begin

      perfect_ = 0B

;+
;     Try a farther-out forecast.
;-
      altFcstHour = TargetFcstHour + 1

      while (altFcstHour le MaxSubFcstHour) do begin

          if (altFcstHour lt MinSubFcstHour) then begin
              altFcstHour = altFcstHour + 1
              CONTINUE
          endif

          cycleDate_Julian = hourEndDate_Julian - $
                             DOUBLE(altFcstHour) / 24.0D
          cycleDate_YYYYMMDDHH = JULIAN_TO_YYYYMMDDHH(cycleDate_Julian)
          cycleDate_YYYY = STRMID(cycleDate_YYYYMMDDHH, 0, 4)
          cycleDate_MM = STRMID(cycleDate_YYYYMMDDHH, 4, 2)
          cycleDate_DD = STRMID(cycleDate_YYYYMMDDHH, 6, 2)

          fcstHourFound_ = altFcstHour

          ;; if KEYWORD_SET(No_subdirs) then $
          ;;     GRIBDir = HRRRDir $
          ;; else $
          ;;     GRIBDir = HRRRDir + $
          ;;               '/' + cycleDate_YYYY + $
          ;;               '/' + cycleDate_MM + $
          ;;               '/' + cycleDate_DD

          ;; GRIBDir_noSubdirs = HRRRDir

          GRIBDir_subdirs = HRRRDir + $
                            '/' + cycleDate_YYYY + $
                            '/' + cycleDate_MM + $
                            '/' + cycleDate_DD

          ;; if KEYWORD_SET(Use_YYDOY) then begin
 
          ;;     cycleDate_YY = STRMID(cycleDate_YYYY, 2, 2)
          ;;     Jan1_Julian = YYYYMMDDHH_TO_JULIAN(cycleDate_YYYY + '010100')
          ;;     dayOfYear = FIX(cycleDate_Julian - Jan1_Julian) + 1
          ;;     cycleDate_DOY = STRING(dayOfYear, FORMAT = '(I3.3)')

          ;;     GRIBFile = cycleDate_YY + cycleDate_DOY + $
          ;;                '.hrrr.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
          ;;                'z.wrfsfcf' + $
          ;;                STRING(altFcstHour, FORMAT = '(I2.2)') + $
          ;;                '.grib2'

          ;; endif else begin

          ;;     GRIBFile = 'hrrr.' + $
          ;;                STRMID(cycleDate_YYYYMMDDHH, 0, 8) + $
          ;;                '.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
          ;;                'z.wrfsfcf' + $
          ;;                STRING(altFcstHour, FORMAT = '(I2.2)') + $
          ;;                '.grib2'
          ;; endelse

          cycleDate_YY = STRMID(cycleDate_YYYY, 2, 2)
          Jan1_Julian = YYYYMMDDHH_TO_JULIAN(cycleDate_YYYY + '010100')
          dayOfYear = FIX(cycleDate_Julian - Jan1_Julian) + 1
          cycleDate_DOY = STRING(dayOfYear, FORMAT = '(I3.3)')

          GRIBFile_YYDOY = cycleDate_YY + cycleDate_DOY + $
                           '.hrrr.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
                           'z.wrfsfcf' + $
                           STRING(altFcstHour, FORMAT = '(I2.2)') + $
                           '.grib2'

          GRIBFile_YYYYMMDD = 'hrrr.' + $
                              STRMID(cycleDate_YYYYMMDDHH, 0, 8) + $
                              '.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
                              'z.wrfsfcf' + $
                              STRING(altFcstHour, FORMAT = '(I2.2)') + $
                              '.grib2'

          GRIBDir = ''
          GRIBFile = ''

          if FILE_TEST(GRIBDir_subdirs, /DIRECTORY) then begin

              case 1 of

                  FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_YYDOY) : begin
                      GRIBDir = GRIBDir_subdirs
                      GRIBFile = GRIBFile_YYDOY
                  end

                  FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_YYYYMMDD) : begin
                      GRIBDir = GRIBDir_subdirs
                      GRIBFile = GRIBFile_YYYYMMDD
                  end

                  else : begin
                      GRIBDir = ''
                      GRIBFile = ''
                  end

              endcase

          endif

          ;; if ((GRIBDir eq '') and (GRIBFile eq '')) then $
          ;;   USR_MSG, '03 HRRR QPF not found in ' + $
          ;;            GRIBDir_subdirs + '/' + GRIBFile_YYDOY + $
          ;;            ' or ' + $
          ;;            GRIBDIR_subdirs + '/' + GRIBFile_YYYYMMDD

          if (FILE_TEST(GRIBDir_noSubdirs) and $
              ((GRIBDir eq '') or (GRIBFile eq ''))) then begin

              case 1 of

                  FILE_TEST(GRIBDir_noSubdirs + '/' + $
                            GRIBFile_YYDOY) : begin
                      GRIBDir = GRIBDir_noSubdirs
                      GRIBFile = GRIBFile_YYDOY
                  end

                  FILE_TEST(GRIBDir_noSubdirs + '/' + $
                            GRIBFile_YYYYMMDD) : begin
                      GRIBDir = GRIBDir_noSubdirs
                      GRIBFile = GRIBFile_YYYYMMDD
                  end

                  else : begin
                      GRIBDir = ''
                      GRIBFile = ''
                  end

              endcase

          endif

          ;; if ((GRIBDir eq '') and (GRIBFile eq '')) then $
          ;;   USR_MSG, '04 HRRR QPF not found in ' + $
          ;;            GRIBDir_noSubdirs + '/' + GRIBFile_YYDOY + $
          ;;            ' or ' + $
          ;;            GRIBDIR_noSubdirs + '/' + GRIBFile_YYYYMMDD

          ;; if FILE_TEST(GRIBDir + '/' + GRIBFile) then BREAK

          if ((GRIBDir ne '') and (GRIBFile ne '') and $
              FILE_TEST(GRIBDir + '/' + GRIBFile)) then BREAK

          altFcstHour = altFcstHour + 1

      endwhile

      if ((altFcstHour le MaxSubFcstHour) and $
          ((GRIBDir eq '') or (GRIBFile eq ''))) then STOP ; PROGRAMMING ERROR

      if ((altFcstHour le MaxSubFcstHour) and $
          KEYWORD_SET(Verbose)) then $
              USR_MSG, 'WARNING: using ' + $
                       STRCRA(altFcstHour) + $
                       '-hour forecast for ' + $
                       HourEndDate_YYYYMMDDHH + '.'

  endif

  if ((GRIBDir eq '') or (GRIBFile eq '') or $
      NOT(FILE_TEST(GRIBDir + '/' + GRIBFile))) then begin

      perfect_ = 0B ; probably not necessary but just in case a file
                    ; suddenly went missing

;+
;     Try a less-far-out forecast.
;-
      altFcstHour = TargetFcstHour - 1

      while (altFcstHour ge MinSubFcstHour) do begin

          if (altFcstHour gt MaxSubFcstHour) then begin
              altFcstHour = altFcstHour - 1
              CONTINUE
          endif

          cycleDate_Julian = hourEndDate_Julian - $
                             DOUBLE(altFcstHour) / 24.0D
          cycleDate_YYYYMMDDHH = JULIAN_TO_YYYYMMDDHH(cycleDate_Julian)
          cycleDate_YYYY = STRMID(cycleDate_YYYYMMDDHH, 0, 4)
          cycleDate_MM = STRMID(cycleDate_YYYYMMDDHH, 4, 2)
          cycleDate_DD = STRMID(cycleDate_YYYYMMDDHH, 6, 2)

          fcstHourFound_ = altFcstHour

          ;; if KEYWORD_SET(No_subdirs) then $
          ;;     GRIBDir = HRRRDir $
          ;; else $
          ;;     GRIBDir = HRRRDir + $
          ;;               '/' + cycleDate_YYYY + $
          ;;               '/' + cycleDate_MM + $
          ;;               '/' + cycleDate_DD

          ;; GRIBDir_noSubdirs = HRRRDir

          GRIBDir_subdirs = HRRRDir + $
                            '/' + cycleDate_YYYY + $
                            '/' + cycleDate_MM + $
                            '/' + cycleDate_DD

          ;; if KEYWORD_SET(Use_YYDOY) then begin

          ;;     cycleDate_YY = STRMID(cycleDate_YYYY, 2, 2)
          ;;     Jan1_Julian = YYYYMMDDHH_TO_JULIAN(cycleDate_YYYY + '010100')
          ;;     dayOfYear = FIX(cycleDate_Julian - Jan1_Julian) + 1
          ;;     cycleDate_DOY = STRING(dayOfYear, FORMAT = '(I3.3)')

          ;;     GRIBFile = cycleDate_YY + cycleDate_DOY + $
          ;;                '.hrrr.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
          ;;                'z.wrfsfcf' + $
          ;;                STRING(altFcstHour, FORMAT = '(I2.2)') + $
          ;;                '.grib2'

          ;; endif else begin

          ;;     GRIBFile = 'hrrr.' + $
          ;;                STRMID(cycleDate_YYYYMMDDHH, 0, 8) + $
          ;;                '.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
          ;;                'z.wrfsfcf' + $
          ;;                STRING(altFcstHour, FORMAT = '(I2.2)') + $
          ;;                '.grib2'
          ;; endelse

          cycleDate_YY = STRMID(cycleDate_YYYY, 2, 2)
          Jan1_Julian = YYYYMMDDHH_TO_JULIAN(cycleDate_YYYY + '010100')
          dayOfYear = FIX(cycleDate_Julian - Jan1_Julian) + 1
          cycleDate_DOY = STRING(dayOfYear, FORMAT = '(I3.3)')

          GRIBFile_YYDOY = cycleDate_YY + cycleDate_DOY + $
                           '.hrrr.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
                           'z.wrfsfcf' + $
                           STRING(altFcstHour, FORMAT = '(I2.2)') + $
                           '.grib2'

          GRIBFile_YYYYMMDD = 'hrrr.' + $
                              STRMID(cycleDate_YYYYMMDDHH, 0, 8) + $
                              '.t' + STRMID(cycleDate_YYYYMMDDHH, 8, 2) + $
                              'z.wrfsfcf' + $
                              STRING(altFcstHour, FORMAT = '(I2.2)') + $
                              '.grib2'

          GRIBDir = ''
          GRIBFile = ''


          if FILE_TEST(GRIBDir_subdirs, /DIRECTORY) then begin

              case 1 of

                  FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_YYDOY) : begin
                      GRIBDir = GRIBDir_subdirs
                      GRIBFile = GRIBFile_YYDOY
                  end

                  FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_YYYYMMDD) : begin
                      GRIBDir = GRIBDir_subdirs
                      GRIBFile = GRIBFile_YYYYMMDD
                  end

                  else : begin
                      GRIBDir = ''
                      GRIBFile = ''
                  end

              endcase

          endif

          ;; if ((GRIBDir eq '') and (GRIBFile eq '')) then $
          ;;   USR_MSG '05 HRRR QPF not found in ' + $
          ;;            GRIBDir_subdirs + '/' + GRIBFile_YYDOY + $
          ;;            ' or ' + $
          ;;            GRIBDIR_subdirs + '/' + GRIBFile_YYYYMMDD

          if (FILE_TEST(GRIBDir_noSubdirs) and $
              ((GRIBDir eq '') or (GRIBFile eq ''))) then begin

              case 1 of

                  FILE_TEST(GRIBDir_noSubdirs + '/' + $
                            GRIBFile_YYDOY) : begin
                      GRIBDir = GRIBDir_noSubdirs
                      GRIBFile = GRIBFile_YYDOY
                  end

                  FILE_TEST(GRIBDir_noSubdirs + '/' + $
                            GRIBFile_YYYYMMDD) : begin
                      GRIBDir = GRIBDir_noSubdirs
                      GRIBFile = GRIBFile_YYYYMMDD
                  end

                  else : begin
                      GRIBDir = ''
                      GRIBFile = ''
                  end

              endcase

          endif

          ;; if ((GRIBDir eq '') and (GRIBFile eq '')) then $
          ;;   USR_MSG, '06 HRRR QPF not found in ' + $
          ;;            GRIBDir_noSubdirs + '/' + GRIBFile_YYDOY + $
          ;;            ' or ' + $
          ;;            GRIBDIR_noSubdirs + '/' + GRIBFile_YYYYMMDD

          ;; if FILE_TEST(GRIBDir + '/' + GRIBFile) then BREAK

          if ((GRIBDir ne '') and (GRIBFile ne '') and $
              FILE_TEST(GRIBDir + '/' + GRIBFile)) then BREAK

          altFcstHour = altFcstHour - 1

      endwhile

      if ((altFcstHour ge MinSubFcstHour) and $
          ((GRIBDir eq '') or (GRIBFile eq ''))) then STOP ; PROGRAMMING ERROR

      if ((altFcstHour ge MinSubFcstHour) and $
          KEYWORD_SET(Verbose)) then $
              USR_MSG, 'WARNING: using ' + $
                       STRCRA(altFcstHour) + $
                       '-hour forecast for ' + $
                       HourEndDate_YYYYMMDDHH + '.'  

  endif

;  if NOT(FILE_TEST(GRIBDir + '/' + GRIBFile)) then begin
  if ((GRIBDir eq '') or (GRIBFile eq '') or $
      NOT(FILE_TEST(GRIBDir + '/' + GRIBFile))) then begin
      if KEYWORD_SET(Verbose) then $
          ERR_MSG, 'No HRRR data found for ' + $
                   HourEndDate_YYYYMMDDHH + '.'
      RETURN
  endif

;+
; Something usable was found.
;-
  dryRunStatus = 1B
  if dryRun then begin
      perfect = TEMPORARY(perfect_)
      fcstHourFound = TEMPORARY(fcstHourFound_)
      RETURN
  endif

  if KEYWORD_SET(Verbose) then $
      USR_MSG, 'Decoding APCP and WEASD from ' + GRIBDir + '/' + GRIBFile

;+
; Define string for forecast portion of GRIB field pattern.
;-
  fcstHour = TargetFcstHour
  if ISA(altFcstHour) then fcstHour = altFcstHour
  fcstString = STRCRA(fcstHour - 1) + '-' + $
               STRCRA(fcstHour) + ' hour acc fcst'


; Verify the expected WEASD record is present.

  matchStr = ':WEASD:surface:' + fcstString + ':'

  cmd = 'wgrib2 -g2clib 0 -match "' + matchStr + '" ' + $
        GRIBDir + '/' + GRIBFile

  SPAWN, cmd, GRIBOut, EXIT_STATUS = status
  if (status eq 0) then begin                      ; so far so good
      if (N_ELEMENTS(GRIBOut eq 1)) then begin     ; still okay
          if (GRIBOut[0] eq '') then begin
              ERR_MSG, 'Failed to decode "' + matchStr + '" ' + $
                       'record/s in ' + GRIBDir + '/' + GRIBFile
              RETURN
          endif
      endif else begin
          ERR_MSG, 'WARNING: multiple matches for "' + matchStr + $
                   '" in ' + GRIBDir + '/' + GRIBFile
      endelse
  endif


; Decode WEASD record.

;  DECODE_GRIB2_FIELD, GRIBFile, GRIBDir, ScratchDir, $
;                      matchStr, $
;                      record, vt, lev, ftime, $
;                      varAbbrev, varField, varUnits, $
;                      nCols_, nRows_, $
;                      WEASDGrid_, $
;                      status, $
;                      NO_DATA_VALUE = NoDataValue

;  if NOT(status) then begin
;      ERR_MSG, 'Failed to decode ":WEASD:" record from ' + $
;               GRIBDir + '/' + GRIBFile
;      RETURN
;  endif

  DECODE_GRIB2_RECORD, GRIBDir + '/' + GRIBFile, $
                       ScratchDir, $
                       matchStr, $
                       record, $
                       vt, $
                       lev, $
                       ftime, $
                       varAbbrev, $
                       varField, $
                       varUnits, $
                       nCols_, $
                       nRows_, $
                       WEASDGrid_, $
                       NO_DATA_VALUE = NoDataValue

  if NOT(ISA(WEASDGrid_)) then begin
      ERR_MSG, 'Failed to decode ":WEASD:" record from ' + $
               GRIBDir + '/' + GRIBFile
      RETURN
  endif


; Check parameters of WEASD GRIB record.

  if (varAbbrev ne 'WEASD') then begin
      ERR_MSG, 'GRIB file ' + GRIBDir + '/' + GRIBFile + $
               ' "WEASD" record has invalid abbreviation ' + $
               '"' + varAbbrev + '".'
      RETURN
  endif
  if (varField ne 'Water Equivalent of Accumulated Snow Depth') $
  then begin
      ERR_MSG, 'GRIB file ' + GRIBDir + '/' + GRIBFile + $
               ' "WEASD" record has invalid field name ' + $
               '"' + varField + '".'
      RETURN
  endif

  if (varUnits ne 'kg/m^2') then begin
      ERR_MSG, 'GRIB file ' + GRIBDir + '/' + GRIBFile + $
               ' "WEASD" record has invalid units ' + $
               '"' + varUnits + '".'
  endif


; Verify the expected APCP record is present.

  matchStr = ':APCP:surface:' + fcstString + ':'

  cmd = 'wgrib2 -g2clib 0 -match "' + matchStr + '" ' + $
        GRIBDir + '/' + GRIBFile

  SPAWN, cmd, GRIBOut, EXIT_STATUS = status
  if (status eq 0) then begin                      ; so far so good
      if (N_ELEMENTS(GRIBOut eq 1)) then begin     ; still okay
          if (GRIBOut[0] eq '') then begin
              ERR_MSG, 'Failed to decode "' + matchStr + '" ' + $
                       'record/s in ' + GRIBDir + '/' + GRIBFile
              RETURN
          endif
      endif else begin
          ERR_MSG, 'WARNING: multiple matches for "' + matchStr + $
                   '" in ' + GRIBDir + '/' + GRIBFile
      endelse
  endif


; Decode APCP record.

  nCols = nCols_
  nRows = nRows_

;  DECODE_GRIB2_FIELD, GRIBFile, GRIBDir, ScratchDir, $
;                      ':APCP:surface:' + fcstString + ':', $
;                      record, vt, lev, ftime, $
;                      varAbbrev, varField, varUnits, $
;                      nCols_, nRows_, $
;                      APCPGrid_, $
;                      status, $
;                      NO_DATA_VALUE = NoDataValue

;  if NOT(status) then begin
;      ERR_MSG, 'Failed to decode ":APCP:" record from ' + $
;               GRIBDir + '/' + GRIBFile
;      RETURN
;  endif

  DECODE_GRIB2_RECORD, GRIBDir + '/' + GRIBFile, $
                       ScratchDir, $
                       matchStr, $
                       record, $
                       vt, $
                       lev, $
                       ftime, $
                       varAbbrev, $
                       varField, $
                       varUnits, $
                       nCols_, $
                       nRows_, $
                       APCPGrid_, $
                       NO_DATA_VALUE = NoDataValue

  if NOT(ISA(APCPGrid_)) then begin
      ERR_MSG, 'Failed to decode ":APCP:" record from ' + $
               GRIBDir + '/' + GRIBFile
      RETURN
  endif


; Check parameters of APCP GRIB record.

  if (varAbbrev ne 'APCP') then begin
      ERR_MSG, 'GRIB file ' + GRIBDir + '/' + GRIBFile + $
               ' "APCP" record has invalid abbreviation ' + $
               '"' + varAbbrev + '".'
      RETURN
  endif
  if (varField ne 'Total Precipitation') $
  then begin
      ERR_MSG, 'GRIB file ' + GRIBDir + '/' + GRIBFile + $
               ' "APCP" record has invalid field name ' + $
               '"' + varField + '".'
      RETURN
  endif

  if (varUnits ne 'kg/m^2') then begin
      ERR_MSG, 'GRIB file ' + GRIBDir + '/' + GRIBFile + $
               ' "APCP" record has invalid units ' + $
               '"' + varUnits + '".'
  endif

  if (nCols_ ne nCols) then begin
      ERR_MSG, 'Grid columns in GRIB file ' + $
               GRIBDir + '/' + GRIBFile + ' "APCP" record ' + $
               'differ from those previously established.'
      RETURN
  endif

  if (nRows_ ne nRows) then begin
      ERR_MSG, 'Grid rows in GRIB file ' + $
               GRIBDir + '/' + GRIBFile + ' "APCP" record ' + $
               'differ from those previously established.'
      RETURN
  endif

  altFcstHour = !NULL

;  endfor
;  endelse

  if NOT(KEYWORD_SET(HRRRGridProjInfo)) then begin


;     Create the HRRRGridProjInfo structure to store grid and
;     projection parameters.

      nCols = nCols_
      nRows = nRows_

      GET_GRIB2_LAMBERT_CONFORMAL_GRID_INFO, $
          GRIBFile, GRIBDir, ScratchDir, $
          ':WEASD:', $
          nCols_, nRows_, $
          lat00, lon00, lonV, latD, latSec1, latSec2, latsp, lonsp, $
          dx, dy, $
          STATUS

      if NOT(status) then begin
          ERR_MSG, 'Failed to read Lambert conformal projection ' + $
                   'parameters from GRIB file ' + $
                   GRIBDir + '/' + GRIBFile + ' "WEASD" record.'
          RETURN
      endif


;     Confirm the NCEP sphere.

;     1. Grid template.
      cmd = 'wgrib2 -match ":WEASD:" -get_byte 3 13 2 ' + $
            GRIBDir + '/' + GRIBFile
      SPAWN, cmd, gridDefTemplate, EXIT_STATUS = status
      if ( status ne 0 ) then begin
          ERR_MSG, 'Failed to read grid definition section in GRIB file ' + $
                   GRIBDir + '/' + GRIBFile + '"WEASD" record.'
          RETURN
      endif
      if ( STRMID ( gridDefTemplate[0], STRLEN ( gridDefTemplate[0] ) - 4, $
           4 ) ne '0,30' ) then begin
          ERR_MSG, 'Grid definition template number (see GRIB2 table 3.1) ' + $
                   '"' + gridDefTemplate[0] + '" not consistent with ' + $
                   ' Lambert Conformal projection.'
          RETURN
      endif
;     2. Shape of the earth.
      cmd = 'wgrib2 -match ":WEASD:" -get_byte 3 15 1 ' + $
            GRIBDir + '/' + GRIBFile
      SPAWN, cmd, shapeOfEarth, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Failed to read Lambert conformal grid template ' + $
                   'in GRIB file ' + $
                   GRIBDir + '/' + GRIBFile + '"WEASD" record.'
          RETURN
      endif
      if (STRMID(shapeOfEarth[0], STRLEN(shapeOfEarth[0]) - 1, 1 ) ne '6' ) $
      then begin
;         '6' = spherical, radius 6371229.0 m
          ERR_MSG, 'NCEP sphere not detected in GRIB file ' + $
                   GRIBDir + '/' + GRIBFile + '"WEASD" record.'
          RETURN
      endif


;     Verify grid size is unchanged.

      if (nCols_ ne nCols) then begin
          ERR_MSG, 'Grid columns in GRIB file ' + $
                   GRIBDir + '/' + GRIBFile + ' "WEASD" record ' + $
                   'have changed.'
          RETURN
      endif
      if (nRows_ ne nRows) then begin
          ERR_MSG, 'Grid rows in GRIB file ' + $
                   GRIBDir + '/' + GRIBFile + ' "WEASD" record ' + $
                   'have changed.'
          RETURN
      endif

;+
;     Create data structure for the HRRR grid and projection.
;-
      HRRRGridProjInfo = $
          {lonV:    lonV, $       ; orientation longitude
           latD:    latD, $       ; latitude where dx and dy are specified
           latSec1: latSec1, $    ; first standard parallel
           latSec2: latSec2, $    ; second standard parallel
           eRadM:   6371229.0D, $ ; NCEP sphere
           lat00:   lat00, $      ; deprojected latitude of LL cell center
           lon00:   lon00, $      ; deprojected longitude of LL cell center
           nCols:   nCols, $      ; # columns
           nRows:   nRows, $      ; # rows
           dx:      dx, $         ; x resolution at latD, meters
           dy:      dy}           ; y resolution at latD, meters

  endif

;+
; Make sure the "lat00" and "lon00" values in HRRRGridProjInfo match
; expectations (regardless of whether that structure was passed to
; this procedure by keyword or generated locally), then force them to
; match the values from HRRR v2 and above, even for data from before
; 2016-08-23 14Z (when HRRR v2 went into operations).
;-
  if ((HRRRGridProjInfo.lat00 ne 21.138000D) and $
      (HRRRGridProjInfo.lat00 ne 21.138123D)) then begin
      ERR_MSG, 'Unexpected HRRRGridProjInfo.lat00 value of ' + $
               STRCRA(STRING(HRRRGridProjInfo.lat00, FORMAT = '(F13.8)'))
      RETURN
  endif

  HRRRGridProjInfo.lat00 = 21.138123D

  if ((HRRRGridProjInfo.lon00 ne -122.720000D) and $
      (HRRRGridProjInfo.lon00 ne -122.719528D)) then begin
      ERR_MSG, 'Unexpected HRRRGridProjInfo.lon00 value of ' + $
               STRCRA(STRING(HRRRGridProjInfo.lon00, FORMAT = '(F13.8)'))
      RETURN
  endif

  HRRRGridProjInfo.lon00 = -122.719528D

;+
; Copy data into output variables.
;-
  WEASDGrid = TEMPORARY(WEASDGrid_)
  APCPGrid = TEMPORARY(APCPGrid_)

  perfect = TEMPORARY(perfect_)
  fcstHourFound = TEMPORARY(fcstHourFound_)

  if (perfect and NOT(KEYWORD_SET(No_save_file)))  then begin


;     Create IDL save file.

      HRRRGridProjInfo_ = HRRRGridProjInfo
      ndv_ = NoDataValue

      SAVE, WEASDGrid, APCPGrid, HRRRGridProjInfo_, ndv_, $
            FILE = ScratchDir + '/' + savFile

      if KEYWORD_SET(Verbose) then $
          USR_MSG, 'APCP and WEASD grids saved to ' + $
                   ScratchDir + '/' + savFile

  endif


  RETURN


end
