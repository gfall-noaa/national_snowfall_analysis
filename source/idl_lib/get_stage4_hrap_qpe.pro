PRO GET_STAGE4_HRAP_QPE, $
    AccumEndDate_YYYYMMDDHH, $       ; end of accumulation
    DurationHours, $                 ; number of hours to aggregate
    St4Dir, $                        ; location of GRIB archive
    ScratchDir, $                    ; location for temp files
    NoDataValue, $
    QPEGrid, $
    HRAP_GRID_PROJ_INFO = HRAPGridProjInfo, $
    NO_ZIP = noZip, $
    VERBOSE = Verbose
;+
; Read Stage IV precipitation from a GRIB version 1 file.
;
; :Params:
;
;     AccumEndDate_YYYYMMDDHH : in, required, type=STRING
;         End time of accumulation period in UTC, in the form
;         YYYYMMDDHH.
;     DurationHours : in, required, type=INT
;         Accumulation duration in hours; e.g., 24 for a day of
;         precipitation accumulation. Must be 1, 6, or 24. This
;         procedure does not aggregate data from multiple files.
;     St4Dir : in, required, type=STRING
;         The directory where Stage IV data are stored.
;     ScratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure and the procedures it calls are stored.
;     NoDataValue : in, required, type=FLOAT
;         The value to use for missing/no-data on all grids. Missing
;         values for input data (e.g., 9.999e20 on GRIB data produced
;         at NCEP) are replaced by this value, and missing/no-data is
;         set to this value for all outputs.
;     QPEGrid : out, type=FLTARR(1121 x 881)
;         The decoded Stage IV precipitation accumulation.
;
; :Keywords:
;
;     HRAP_GRID_PROJ_INFO : type=STRUCT
;         A named variable that will capture the structure describing
;         the HRAP (polar stereographic) grid and coordinate
;         system. If this variable is undefined, it will be
;         defined. If it is already defined, it will be verified
;         against the contents of the input GRIB file.
;         Structure tags:
;
;         lonV (type=DOUBLE):
;         The orientation longitude, degrees.
;
;         latD (type=DOUBLE):
;         The latitude where the grid spacing is defined, degrees.
;
;         eRadM (type=DOUBLE)
;         The radius of the spherical earth in the projection, meters.
;
;         lat00 (type=DOUBLE)
;         The lower left grid cell center latitude, degrees.
;
;         lon00 (type=DOUBLE):
;         The lower left grid cell center longitude, degrees.
;
;         nCols (type=LONG):
;         The number of columns in the GRIB record.
;
;         nRows (type=LONG):
;         The number of rows in the GRIB record.
;
;         dx (type=DOUBLE):
;         The grid spacing in x, meters.
;
;         dy (type=DOUBLE):
;         The grid spacing in y, meters.
;
;     NO_ZIP : in, type=BOOLEAN
;         A deprecated keyword that instructed the procedure not to
;         look for a compressed GRIB file. This is no longer needed,
;         since the procedure is able to interpret the GRIB file name
;         with a decent degree of flexibility. This keyword is
;         ignored if it is present, and is supported only for backward
;         compatibility.
;
;     VERBOSE : in, type=BOOLEAN
;         Activates the "verbose" option, causing this procedure to
;         produce some extra output text.
;-
  COMMON info, Message ; used by USR_MSG and ERR_MSG

;+
; Initialize output grid to !NULL. The caller should use
; ISA(QPEGrid) to judge the success/failure of this procedure.
;-
  QPEGrid = !NULL

;+
; Check arguments for correct type and valid contents.
;-
  if NOT(ISA(AccumEndDate_YYYYMMDDHH, 'STRING')) then begin
      ERR_MSG, 'Target accumulation end date/time argument must be a STRING.'
      RETURN
  endif
  if (STRLEN(AccumEndDate_YYYYMMDDHH) ne 10) then begin
      ERR_MSG, 'Invalid target accumulation end date/time "' + $
               AccumEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, 10 digits).'
      RETURN
  endif
  if NOT(STREGEX(AccumEndDate_YYYYMMDDHH, '[0-9]{10}', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Invalid target accumulation end date/time "' + $
               AccumEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, all numeric).'
      RETURN
  endif

  accumEndDate_Julian = YYYYMMDDHH_TO_JULIAN(AccumEndDate_YYYYMMDDHH)
  accumEndDate_YYYYMMDD = STRMID(AccumEndDate_YYYYMMDDHH, 0, 8)
  accumEndDate_YYYY = STRMID(AccumEndDate_YYYYMMDDHH, 0, 4)
  accumEndDate_MM = STRMID(AccumEndDate_YYYYMMDDHH, 4, 2)
  accumEndDate_DD = STRMID(AccumEndDate_YYYYMMDDHH, 6, 2)
  accumEndDate_HH = STRMID(AccumEndDate_YYYYMMDDHH, 8, 2)

  if (DurationHours lt 0) then begin
      ERR_MSG, 'Duration must be a positive integer number of hours.'
      RETURN
  endif
  if (DurationHours gt 999) then begin
      ERR_MSG, 'Duration argument cannot exceed 999 hours.'
      RETURN
  endif

  if NOT(ISA(St4Dir, 'STRING')) then begin
      ERR_MSG, 'Location of Stage IV archive must be a STRING.'
      RETURN
  endif
  if NOT(FILE_TEST(St4Dir, /DIRECTORY)) then begin
      ERR_MSG, 'Stage IV archive directory "' + St4Dir + '" not found.'
      RETURN
  endif
  if NOT(FILE_TEST(St4Dir, /READ)) then begin
      ERR_MSG, 'Stage IV archive directory "' + St4Dir + '" not readable.'
      RETURN
  endif

  if NOT(ISA(ScratchDir, 'STRING')) then begin
      ERR_MSG, 'Location of scratch directory must be a STRING.'
      RETURN
  endif
  if NOT(FILE_TEST(ScratchDir, /DIRECTORY)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not found.'
      RETURN
  endif
  if NOT(FILE_TEST(ScratchDir, /READ)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not readable.'
      RETURN
  endif
  if NOT(FILE_TEST(ScratchDir, /WRITE)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not writeable.'
      RETURN
  endif
  if NOT(ISA(NoDataValue, 'FLOAT')) then $
      USR_MSG, 'WARNING: no-data value should be a floating point value.'

  if KEYWORD_SET(HRAPGridProjInfo) then begin

;+
;     Verify the structure of HRAPGridProjInfo.
;-
      sizeHRAPGridProjInfo = SIZE(HRAPGridProjInfo)
      if (sizeHRAPGridProjInfo[0] ne 1) then begin
          ERR_MSG, 'HRAP_GRID_PROJ_INFO structure mismatch (non-scalar).'
          RETURN
      endif

      if ((sizeHRAPGridProjInfo[1] ne 1) or $
          (sizeHRAPGridProjInfo[2] ne 8)) then begin
          ERR_MSG, 'HRAP_GRID_PROJ_INFO structure mismatch ' + $
                   '(not a structure).'
          RETURN
      endif

      sizeHRAPGridProjInfo = !NULL

      structOk = 1

      tagNames = TAG_NAMES(HRAPGridProjInfo)

      ind = WHERE(tagNames eq 'LONV', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lonV" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'LATD', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latD" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'ERADM', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "eRadM" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'LAT00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lat00" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'LON00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lon00" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'NCOLS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nCols" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'NROWS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nRows" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'DX', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dx" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif
      ind = WHERE(tagNames eq 'DY', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dy" tag in HRAP_GRID_PROJ_INFO.'
          structOk = 0
      endif

      if structOk then begin

          if NOT(ISA(HRAPGridProjInfo.lonV, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "lonV" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.latD, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "latD" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.eRadM, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "eRadM" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.lat00, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "lat00" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.lon00, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "lon00" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.nCols, 'LONG')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "nCols" is not ' + $
                       'type LONG.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.nRows, 'LONG')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "nRows" is not ' + $
                       'type LONG.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.dx, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "dx" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif
          if NOT(ISA(HRAPGridProjInfo.dy, 'DOUBLE')) then begin
              ERR_MSG, 'HRAP_GRID_PROJ_INFO element "dy" is not ' + $
                       'type DOUBLE.'
              structOk = 0
          endif

      endif

      if NOT(structOk) then begin
          ERR_MSG, 'Unexpected structure/content in HRAP_GRID_PROJ_INFO ' + $
                   'structure.'
          RETURN
      endif

      structOK = !NULL

  endif

;+
; Locate the GRIB file.
;-
  GRIBDir_noSubdirs = St4Dir

  GRIBDir_subdirs = St4Dir + '/' + accumEndDate_YYYY + '/' + $
                    accumEndDate_YYYYMMDD

  GRIBDir = ''
  GRIBFile = ''
  file = !NULL
  count = 0
  GRIB_version = !NULL

;+
; Look for a gzipped GRIB 1 file in a YYYY/YYYYMMDD subdirectory.
;-
  GRIBFile_noExt = 'ST4.' + accumEndDate_YYYYMMDDHH + '.' + $
                   STRING(DurationHours, FORMAT = '(I2.2)') + 'h'

  if FILE_TEST(GRIBDir_subdirs, /DIRECTORY) then begin

      if FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_noExt + '.gz') then begin
          GRIBDir = GRIBDir_subdirs
          file = [file, GRIBFile_noExt + '.gz']
          count = count + 1
      endif
      if FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_noExt + '.Z') then begin
          GRIBDir = GRIBDir_subdirs
          file = [file, GRIBFile_noExt + '.Z']
          count = count + 1
      endif
      if (GRIBDir ne '') then begin
          if (count gt 1) then begin
              ERR_MSG, 'WARNING: reading ' + $
                       GRIBDir + '/' + file[0] + ';'
              for fc = 1, count - 1 do begin
                  ERR_MSG, 'ignoring ' + $
                           GRIBDir + '/' + file[fc]
              endfor
          endif
          GRIBFile = file[0]
          GRIB_version = 1
      endif

  endif

;+
; Look for a gzipped GRIB 1 file in a top-level directory.
;-
  if (FILE_TEST(GRIBDir_noSubdirs, /DIRECTORY) and $
      ((GRIBDir eq '') or (GRIBFile eq ''))) then begin

      if (count ne 0) then STOP ; PROGRAMMING ERROR
      if ISA(file) then STOP    ; PROGRAMMING ERROR

      if FILE_TEST(GRIBDir_noSubdirs + '/' + GRIBFile_noExt + '.gz') then begin
          GRIBDir = GRIBDir_noSubdirs
          file = [file, GRIBFile_noExt + '.gz']
          count = count + 1
      endif
      if FILE_TEST(GRIBDir_noSubdirs + '/' + GRIBFile_noExt + '.Z') then begin
          GRIBDir = GRIBDir_noSubdirs
          file = [file, GRIBFile_noExt + '.Z']
          count = count + 1
      endif
      if (GRIBDir ne '') then begin
          if (count gt 1) then begin
              ERR_MSG, 'WARNING: reading ' + $
                       GRIBDir + '/' + file[0] + ';'
              for fc = 1, count - 1 do begin
                  ERR_MSG, 'ignoring ' + $
                           GRIBDir + '/' + file[fc]
              endfor
          endif
          GRIBFile = file[0]
          GRIB_version = 1
      endif

  endif

  if (((GRIBDir eq '') or (GRIBFile eq '')) and $
      (FIX(accumEndDate_YYYY) ge 2020) and $
      (FIX(accumEndDate_MM) ge 7)) then begin
;+
;     No GRIB 1 file found. Try GRIB 2.
;-
      GRIBFile_expected = 'st4_conus.' + accumEndDate_YYYYMMDDHH + '.' + $
                          STRING(DurationHours, FORMAT = '(I2.2)') + 'h.grb2'

;+
;     Look for a GRIB 2 file in a YYYY/YYYYMMDD subdirectory.
;-
      if (FILE_TEST(GRIBDir_subdirs, /DIRECTORY)) then begin

          if FILE_TEST(GRIBDir_subdirs + '/' + GRIBFile_expected) then begin
              GRIBDir = GRIBDir_subdirs
              GRIBFile = GRIBFile_expected
              GRIB_version = 2
          endif

      endif

      if (FILE_TEST(GRIBDir_noSubdirs, /DIRECTORY) and $
          ((GRIBDir eq '') or (GRIBFile eq ''))) then begin

;+
;         Look for a GRIB 2 file in a top-level directory.
;-
          if FILE_TEST(GRIBDir_noSubdirs + '/' + GRIBFile_expected) then begin
              GRIBDir = GRIBDir_noSubdirs
              GRIBFile = GRIBFile_expected
              GRIB_version = 2
          endif

      endif

  endif

  if ((GRIBDir eq '') or (GRIBFile eq '')) then begin
      if KEYWORD_SET(Verbose) then begin
          msg = 'No GRIB files matching "' + GRIBFile_noExt + '[.gz,.Z]"'
          if ((FIX(accumEndDate_YYYY) ge 2020) and $
              (FIX(accumEndDate_MM) ge 7)) then $
              msg = msg + ' or "' + GRIBFile_expected + '"'
          msg = msg + ' found in either ' + GRIBDir_subdirs + ' or ' + $
                GRIBDir_noSubdirs
          ERR_MSG, msg
      endif
      RETURN
  endif

  GRIBFilePath = GRIBDir + '/' + GRIBFile

  GRIBFieldAbbrev = 'APCP'      ; total precipitation

  if (GRIB_version eq 1) then $
      DECODE_GRIB1_RECORD, GRIBFilePath, $
                           ScratchDir, $
                           GRIBFieldAbbrev, $
                           units, $
                           refTime_YYYYMMDDHH, $
                           timeRange, $
                           p1, $
                           p2, $
                           nx, $
                           ny, $
                           QPEGrid_, $
                           NO_DATA_VALUE = NoDataValue $
  else $
      DECODE_GRIB2_RECORD, GRIBFilePath, $
                           ScratchDir, $
                           GRIBFieldAbbrev, $
                           record, $
                           verificationTime_YYYYMMDDHH, $
                           level, $
                           timeRange, $
                           varAbbrev, $
                           varField, $
                           units, $
                           nx, $
                           ny, $
                           QPEGrid_, $
                           NO_DATA_VALUE = NoDataValue

  if NOT(ISA(QPEGrid_)) then begin
      ERR_MSG, 'Failed to decode "' + GRIBFieldAbbrev + '" from ' + $
               GRIBFilePath
      RETURN
  endif

  expectedUnits = 'kg/m^2'
  if (units ne expectedUnits) then begin
      ERR_MSG, 'GRIB record units "' + units + '" ' + $
               'does not match expected value "' + expectedUnits + '".'
      RETURN
  endif

  if (nx ne 1121) then begin
      ERR_MSG, 'GRIB record # columns (' + $
               STRCOMPRESS(nx, /REMOVE_ALL) + $
               ') does not match expected value (1121).'
      RETURN
  endif
            
  if (ny ne 881) then begin
      ERR_MSG, 'GRIB record # rows (' + $
               STRCOMPRESS(ny, /REMOVE_ALL) + $
               ') does not match expected value (881).'
      RETURN
  endif

  if NOT(KEYWORD_SET(HRAPGridProjInfo)) then begin

;+
;     Create the HRAPGridProjInfo structure to store grid and
;     projection parameters.
;-

;+
;     Get grid geometry and projection information.
;-
      if (GRIB_version eq 1) then $
          GET_GRIB1_POLAR_STEREO_GRID_INFO, $
              GRIBFilePath, $
              ScratchDir, $
              GRIBFieldAbbrev, $
              nx_, $
              ny_, $
              lat00, $
              lon00, $
              latd, $
              lonv, $
              dx, $
              dy, $
              status $
      else $
          GET_GRIB2_POLAR_STEREO_GRID_INFO, $
              GRIBFilePath, $
              GRIBFieldAbbrev, $
              nx_, $
              ny_, $
              lat00, $
              lon00, $
              latd, $
              lonv, $
              dx, $
              dy, $
              status

      if NOT(status) then begin
          ERR_MSG, 'Failed to read GRIB header from ' + $
                   GRIBFilePath
          RETURN
      endif

      if (nx_ ne 1121) then begin
          ERR_MSG, 'GRIB header # columns (' + $
                   STRCOMPRESS(nx_, /REMOVE_ALL) + $
                   ') does not match expected value (1121).'
          RETURN
      endif
            
      if (ny_ ne 881) then begin
          ERR_MSG, 'GRIB header # rows (' + $
                   STRCOMPRESS(ny_, /REMOVE_ALL) + $
                   ') does not match expected value (881).'
          RETURN
      endif
  
;+
;     Create data structure for the HRAP grid and projection. The
;     limitations of the GRIB version 1 specification lead to
;     insufficient precision for grid/projection parameters. Here we
;     verify the parameters as they will be interpreted by the wgrib
;     program, then use more precise replacement values.
;-
      if (GRIB_version eq 1) then begin

          if (dx ne 4763.0D) then begin
              ERR_MSG, 'Unexpected "dx" value in Stage IV file ' + $
                       GRIBFilePath
              RETURN
          endif
          if (dy ne 4763.0D) then begin
              ERR_MSG, 'Unexpected "dy" value in Stage IV file ' + $
                       GRIBFilePath
              RETURN
          endif

          dx = 4762.5D
          dy = 4762.5D

      endif

      if (dx ne 4762.5D) then begin
          ERR_MSG, 'Unexpected "dx" value in Stage IV file ' + $
                   GRIBFilePath
          RETURN
      endif
      if (dy ne 4762.5D) then begin
          ERR_MSG, 'Unexpected "dy" value in Stage IV file ' + $
                   GRIBFilePath
          RETURN
      endif

      if (STRCRA(STRING(lat00, FORMAT = '(F8.4)')) ne '23.1170') then begin
          ERR_MSG, 'Unexpected "lat1" value in Stage IV file ' + $
                   GRIBFilePath
          RETURN
      endif
      if (STRCRA(STRING(lon00, FORMAT = '(F9.4)')) ne '-119.0230') then begin
          ERR_MSG, 'Unexpected "lon1" value in Stage IV file ' + $
                   GRIBFilePath
          RETURN
      endif

      lat00 = 23.1167684D       ; 23.11676840356748386
      lon00 = -119.0236000D     ; -119.02360004492176415

      HRAPGridProjInfo = $
          {lonV:  lonV, $           ; orientation longitude
           latD:  latD, $           ; lat where dx and dy are specified
           eRadM: 6371200.0D, $     ; NCEP sphere radius, meters
           lat00: lat00, $          ; deprojected lat of LL cell center
           lon00: lon00, $          ; deprojected lon of LL cell center
           nCols: nx, $             ; # columns
           nRows: ny, $             ; # rows
           dx:    dx, $             ; x resolution at latD, meters
           dy:    dy}               ; y resolution at latD, meters

  endif

;+
; Rename QPEGrid_ to QPEGrid to establish that the procedure ran
; successfully.
;-
  QPEGrid = TEMPORARY(QPEGrid_)

  RETURN

end
