PRO DECODE_GRIB1_RECORD, GRIBFilePath, $           ; IN
                         ScratchDir, $             ; IN
                         Field, $                  ; IN
                         units, $                  ; OUT
                         refTime_YYYYMMDDHH, $     ; OUT
                         timeRange, $              ; OUT
                         p1, $                     ; OUT
                         p2, $                     ; OUT
                         nx, $                     ; OUT
                         ny, $                     ; OUT
                         data, $                   ; OUT
                         NO_DATA_VALUE = Ndv

;+
; Decode a record from a GRIB version 1 file.
;
; :Params:
;     GRIBFilePath : in, required, type=STRING
;         The GRIB1 file path. Files that have gzip extensions will be
;         identified and unzipped non-disruptively prior to decoding.
;     ScratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure are stored.
;     Field : in, required, type=STRING
;         The GRIB1 parameter abbreviation. See
;         `http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html <http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html>`
;     units : out, type=STRING
;         The units of the data in the GRIB record.
;     refTime_YYYYMMDDHH : out, type=STRING
;         The reference time for the GRIB record.
;     timeRange : out, type=STRING
;         The type of time range represented by the data.
;     p1 : out, type=DOUBLE
;         Relative to refTime_YYYYMMDDHH, the start of the time range
;         represented by the data.
;     p2 : out, type=DOUBLE
;         Relative to refTime_YYYYMMDDHH, the end of the time range
;         represented by the data.
;     nx : out, type=LONG
;         The number of columns in the GRIB record data.
;     ny : out, type=LONG
;         The number of rows in the GRIB record data.
;     data : out, type=FLOAT
;         The 2-D array of GRIB record data.
;
; :Keywords:
;     NO_DATA_VALUE : in, type=FLOAT
;         The value to use for missing data in the GRIB record
;         data. The value stored in the GRIB record itself will be
;         9.999e20, and all cells having this value will be changed to
;         the NO_DATA_VALUE setting.
;-

;+
; Initialize output grid to !NULL. The caller should use
; ISA(MRMSWtGrid) to judge the success/failure of this procedure.
;-
  data = !NULL

;+
; TODO: check all arguments for validity.
;-
  if NOT(FILE_TEST(GRIBFilePath)) then begin
      ERR_MSG, 'File "' + GRIBFilePath + '" not found.'
      RETURN
  endif

;+
; Deal with zipped files. If the GRIBFilePath ends with one of the
; extensions below, this procedure will attempt to use the gzip
; utility to decompress a copy of the file before reading it.
;-
  GRIBFile = FILE_BASENAME(GRIBFilePath)

  gz1Pos = STRPOS(GRIBFile, '.gz', 2, /REVERSE_SEARCH, /REVERSE_OFFSET)
  gz2pos = STRPOS(GRIBFile, '-gz', 2, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z1Pos = STRPOS(GRIBFile, '.z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z2Pos = STRPOS(GRIBFile, '-z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z3Pos = STRPOS(GRIBFile, '_z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z4Pos = STRPOS(GRIBFile, '.Z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  zipPos = [gz1Pos, gz2Pos, z1Pos, z2Pos, z3Pos, z4Pos]
  ind = WHERE(zipPos ne -1, count)
  if (count eq 1) then begin

;+
;     Copy the file to the ScratchDir.
;-
      cmd = 'cp --preserve=mode,timestamps ' + $
            GRIBFilePath + ' ' + ScratchDir
      SPAWN, cmd, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Failed to copy ' + GRIBFilePath + ' to ' + ScratchDir
          RETURN
      endif
      if NOT(FILE_TEST(ScratchDir + '/' + GRIBFile)) then begin
          ERR_MSG, 'File copy ' + ScratchDir + '/' + GRIBFile + $
                   ' not found.'
          RETURN
      endif

      ind = ind[0]
      SPAWN, 'gzip -d ' + ScratchDir + '/' + GRIBFile, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Command "gzip -d ' + ScratchDir + '/' + GRIBFile + $
                   '" failed.'
          RETURN
      endif
      tmpGRIBFile = STRMID(GRIBFile, 0, zipPos[ind])
      if NOT(FILE_TEST(ScratchDir + '/' + tmpGRIBFile)) then begin
          ERR_MSG, 'Output file missing after command "gzip -d ' + $
                   ScratchDir + '/' + GRIBFile + '".'
          RETURN
      endif

      inputPath = ScratchDir + '/' + tmpGRIBFile

  endif else begin

      tmpGRIBFile = GRIBFile
      inputPath = GRIBFilePath

  endelse

;+
; Generate a (probably) unique temporary file name for decoded data
; using the date and process ID.
;-
  SPAWN, 'date -u +%Y%m%d%H%M%S', dateStr
  dateStr = dateStr[0]
  pidStr = STRCRA(GETPID())
  tmpGRIBRaster = ScratchDir + '/tmpGRIBRaster.' + dateStr + '.' + pidStr
;  tmpGRIBHeader = ScratchDir + '/tmpGRIBHeader.' + dateStr + '.' + pidStr

;+
; Decode the GRIB record, storing results header string and data
; file.
;-
  cmd = 'wgrib -v ' + inputPath + $
        ' | grep -E "' + Field + '"' + $
        ' | wgrib -i -V ' + inputPath + $
         ' -o ' + tmpGRIBRaster
  SPAWN, cmd, hdr, EXIT_STATUS = status
  if (status ne 0) then begin
      ERR_MSG, 'Command "' + cmd + '" failed.'
      RETURN
  endif

;+
; Delete the temporary copy if gzip was used.
;-
  if (inputPath eq ScratchDir + '/' + tmpGRIBFile) then $
      FILE_DELETE, inputPath

;+
; Verify the output header is the expected size.'
;-
  if (N_ELEMENTS(hdr) ne 8) then begin
      ERR_MSG, 'Invalid output header.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

;+
; Check the data file size.  The wgrib2 program does not necessarily
; give a nonzero exit status when it fails.
;-
  rInfo = FILE_INFO(tmpGRIBRaster)
  if (rInfo.size eq 0L) then begin
      ERR_MSG, 'FATAL: wgrib2 produced an empty raster file.'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

;+
; Sample GRIB1 header:
;
;   rec 1:0:date 2017110911 APCP kpds5=61 kpds6=1 kpds7=0 levels=(0,0) grid=255 sfc 0-1hr acc: bitmap: 480079 undef
;     APCP=Total precipitation [kg/m^2]
;     timerange 4 P1 0 P2 1 TimeU 1  nx 1121 ny 881 GDS grid 5 num_in_ave 0 missing 0
;     center 7 subcenter 4 process 182 Table 2 scan: WE:SN winds(grid) 
;     polar stereo: Lat1 23.117000 Long1 -119.023000 Orient -105.000000
;        north pole (1121 x 881) Dx 4763 Dy 4763 scan 64 mode 8
;     min/max data 0 21.88  num bits 12  BDS_Ref 0  DecScale 2 BinScale 0
;-

;+
; Read the GRIB1 header.
;-
  c1 = STRPOS(hdr[0], 'date ') + 5
  if (c1 eq -1) then begin
      ERR_MSG, 'FATAL: "date" not found in GRIB inventory ' + $
               '(' + hdr[0] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS(hdr[0], ' ', c1)
  if ((c2 - c1) ne 10) then begin
      ERR_MSG, 'FATAL: unknown date format in GRIB inventory ' + $
               '(' + hdr[0] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  refTime_YYYYMMDDHH = STRMID(hdr[0], c1, c2 - c1)

  c1 = STRPOS(hdr[0], Field + ' ', c2)
  if (c1 eq -1) then begin
      ERR_MSG, 'FATAL: field "' + Field + '" not found in GRIB inventory ' + $
               '(' + hdr[0] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

  c1 = STRPOS (hdr[1], Field + '=')
  if (c1 eq -1) then begin
      ERR_MSG, 'FATAL: field "' + Field + '" not found in GRIB ' + $
               'inventory (' + hdr[1] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c1 = STRPOS(hdr[1], '[', c1) + 1
  if (c1 eq -1) then begin
      ERR_MSG, 'FATAL: unknown units format in GRIB inventory ' + $
               '(' + hdr[1] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS(hdr[1], ']', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown units format in GRIB inventory ' + $
               '(' + hdr[1] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  units = STRMID(hdr[1], c1, c2 - c1)

;+
; See http://rda.ucar.edu/docs/formats/grib/gribdoc/timer.html for
; info on PDS octet 21 (timerange).
;
; See also
;
;   http://rda.ucar.edu/docs/formats/grib/gribdoc/pds.html and
;   ftp://ftp.cpc.ncep.noaa.gov/wd51we/wgrib/readme
;-
  c1 = STRPOS(hdr[2], 'timerange ') + 10
  if (c1 eq 9) then begin
      ERR_MSG, 'FATAL: "timerange" not found in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS (hdr[2], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown timerange format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  timeRangeCode = FIX(STRMID(hdr[2], c1, c2 - c1))
  case timeRangeCode of
      0: timeRange = 'fcst'  ; forecast refTime + P1
      1: timeRange = 'anl'   ; analysis refTime, P1 = 0, P2 irrelevant
      2: timeRange = 'valid' ; valid between refTime + P1 and refTime + P2
      3: timeRange = 'ave'   ; average from refTime + P1 to refTime + P2
      4: timeRange = 'acc'   ; accumulation from refTime + P1 to refTime + P2
      5: timeRange = 'diff'  ; difference between refTime + P2 - refTime + P1,
                             ; valid at refTime + P2
      else: begin
          ERR_MSG, 'Unsupported timerange ' + $
                   STRCOMPRESS ( timeRangeCode, /REMOVE_ALL )
          timeRange = '???'
      end
  endcase

  c1 = STRPOS(hdr[2], 'P1 ', c1) + 3
  if (c1 eq 2) then begin
      ERR_MSG, 'FATAL: unknown "P1" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

  c2 = STRPOS(hdr[2], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown "P1" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  p1 = DOUBLE(STRMID(hdr[2], c1, c2 - c1))

  c1 = STRPOS(hdr[2], 'P2 ', c2) + 3
  if (c1 eq 2) then begin
      ERR_MSG, 'FATAL: unknown "P2" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS(hdr[2], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown "P2" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  p2 = DOUBLE(STRMID(hdr[2], c1, c2 - c1))

  c1 = STRPOS(hdr[2], 'nx ') + 3
  if (c1 eq 2) then begin
      ERR_MSG, 'FATAL: unknown "nx" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS(hdr[2], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown "nx" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  nx = LONG(STRMID(hdr[2], c1, c2 - c1))

  c1 = STRPOS(hdr[2], 'ny ', c2) + 3
  if (c1 eq 2) then begin
      ERR_MSG, 'FATAL: unknown "ny" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS(hdr[2], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown "ny" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  ny = LONG(STRMID(hdr[2], c1, c2 - c1))

  c1 = STRPOS(hdr[6], 'min/max data ') + 13
  if (c1 eq 12) then begin
      ERR_MSG, 'FATAL: unknown "min/max" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  c2 = STRPOS(hdr[6], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown "min/max" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  minVal = STRMID(hdr[6], c1, c2 - c1)

  c1 = c2 + 1
  c2 = STRPOS(hdr[6], ' ', c1)
  if (c2 eq -1) then begin
      ERR_MSG, 'FATAL: unknown "min/max" format in GRIB inventory ' + $
               '(' + hdr[2] + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif
  maxVal = STRMID(hdr[6], c1, c2 - c1)

;+
; Read the grid.
;-
  OPENU, lun, tmpGRIBRaster, /GET_LUN

  gridSizeBytes = 0L
  READU, lun, gridSizeBytes ; rows * columns * sizeof(float)

  if (gridSizeBytes ne (nx * ny * 4L)) then begin
      ERR_MSG, 'Mismatch between grid bytes (' + STRCRA(gridSizeBytes) + $
               ') and expected value (' + STRCRA(nx * ny * 4L) + ').'
      FILE_DELETE, tmpGRIBRaster, /QUIET
      RETURN
  endif

  data_ = FLTARR(nx, ny)
  READU, lun, data_

  FREE_LUN, lun
  FILE_DELETE, tmpGRIBRaster

  if KEYWORD_SET(ndv) then begin
      if (ndv eq 1) then begin
          ERR_MSG, 'WARNING: NO_DATA_VALUE keyword should be explicitly ' + $
                   'assigned a value. Using 9.999e20.'
          ndv = 9.999e20
      endif
      index = WHERE(data_ eq 9.999e20, count)
      if (count gt 0) then data_[index] = ndv
  endif

  data = TEMPORARY(data_)

  RETURN

end
