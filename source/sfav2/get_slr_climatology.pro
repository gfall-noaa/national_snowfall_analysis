PRO GET_SLR_CLIMATOLOGY, TargetDate_YYYYMMDD, $
                         SLRDir, $
                         MinLonOut_, MaxLonOut_, $
                         MinLatOut_, MaxLatOut_, $
                         XResOut_, YResOut_, $
                         Ndv, $
                         SLRGrid, $
                         PAD = Pad, $
                         REMOVE_NDV = RemoveNdv, $
                         YEAR_RANGE = yearRange

  COMMON info, Message

  SLRGrid = !NULL


; Use monthly (October through April) climatological
; snowfall-to-liquid equivalent (SLR) data to estimate SLR.

; For dates between October 15 and April 14, interpolate temporally
; between monthly data.

; For October 1-14, use October climatology.
; For April 16-30, use April climatology.
; For May through September, use the "Summer" climatology.

; Greg Fall, OWP-Chanhassen, 

; 2018-08-06, Greg Fall and Kent Sparrow:
;             Modified climatology dates from 1986-2015 to 1988-2017,
;             to use updated climatology.
; 2019-08-26, Greg Fall:
;             Modified logic so that beginning in October 2018, the
;             procedure looks for a climatology from year-30 to
;             year-1, rather than hard-coding the climatology.
;             Added keyword YEAR_RANGE to return the last yearRange
;             string generated by the procedure, as a (imperfect
;             because for December 16 to January 14 you use
;             climatologies covering different year ranges)
;             description of the years covered by the climatology.

; Check arguments for correct type and valid contents.

  if NOT(ISA(TargetDate_YYYYMMDD, 'STRING')) then begin
      ERR_MSG, 'Target date argument must be a STRING.'
      RETURN
  endif
  if (STRLEN(TargetDate_YYYYMMDD) ne 8) then begin
      ERR_MSG, 'Invalid target date "' + $
               TargetDate_YYYYMMDD + $
               '" (required form is YYYYMMDD, 8 digits).'
      RETURN
  endif
  if NOT(STREGEX(TargetDate_YYYYMMDD, '[0-9]{8}', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Invalid target date "' + $
               TargetDate_YYYYMMDD + $
               '" (required form is YYYYMMDD, all numeric).'
      RETURN
  endif

  targetDate_Julian = YYYYMMDDHH_TO_JULIAN(TargetDate_YYYYMMDD + '12')
  targetDate_YYYY = STRMID(TargetDate_YYYYMMDD, 0, 4)
  targetDate_MM = STRMID(TargetDate_YYYYMMDD, 4, 2)
  targetDate_DD = STRMID(TargetDate_YYYYMMDD, 6, 2)

  if NOT(ISA(SLRDir, 'STRING')) then begin
      ERR_MSG, 'Location of SLR archive must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(SLRDir, /DIRECTORY)) then begin
      ERR_MSG, 'SLR archive directory "' + SLRDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(SLRDir, /READ)) then begin
      ERR_MSG, 'SLR archive directory "' + SLRDir + '" not readable.'
      RETURN
  endif

  if NOT(ISA(MinLonOut_, 'DOUBLE')) then $
      minLonOut = DOUBLE(MinLonOut_) $
  else $
      minLonOut = MinLonOut_

  if NOT(ISA(MaxLonOut_, 'DOUBLE')) then $
      maxLonOut = DOUBLE(MaxLonOut_) $
  else $
      maxLonOut = MaxLonOut_

  if NOT(ISA(MinLatOut_, 'DOUBLE')) then $
      minLatOut = DOUBLE(MinLatOut_) $
  else $
      minLatOut = MinLatOut_

  if NOT(ISA(MaxLatOut_, 'DOUBLE')) then $
      maxLatOut = DOUBLE(MaxLatOut_) $
  else $
      maxLatOut = MaxLatOut_

  if NOT(ISA(XResOut_, 'DOUBLE')) then $
      xResOut = DOUBLE(XResOut_) $
  else $
      xResOut = XResOut_

  if NOT(ISA(YResOut_, 'DOUBLE')) then $
      yResOut = DOUBLE(YResOut_) $
  else $
      yResOut = YResOut_

  nxOut = ROUND((maxLonOut - minLonOut) / xResOut)
  nyOut = ROUND((maxLatOut - minLatOut) / yResOut)

  xErr = ABS(nxOut * xResOut - (maxLonOut - minLonOut))
  if (xERR gt 1.0D-8) then begin
      ERR_MSG, 'Inconsistent longitudinal domain/resolution.'
      RETURN
  endif
  yErr = ABS(nyOut * yResOut - (maxLatOut - minLatOut))
  if (yErr gt 1.0D-8) then begin
      ERR_MSG, 'Inconsistent latitudinal domain/resolution.'
      RETURN
  endif
;GF
  ;PRINT, 'Getting SLR climatology for ' + TargetDate_YYYYMMDD

; Define the neighborhood parameters for fixing no-data values.

  hoodMinMeters = 100.0D3
  hoodStepMeters = 20.0D3
  hoodMaxMeters = 100.0D3
  hoodMinNVal = 10


; Work backward until we reach the prior mid-month.

  dayOfMonth = FIX(targetDate_DD)
  daysBackTo15th = 0
  date_Julian = targetDate_Julian
  date_YYYYMMDD = TargetDate_YYYYMMDD
  while (dayOfMonth ne 15) do begin
      date_Julian = date_Julian - 1.0D
      date_YYYYMMDD = STRMID(JULIAN_TO_YYYYMMDDHH(date_Julian), 0, 8)
      dayOfMonth = FIX(STRMID(date_YYYYMMDD, 6, 2))
      daysBackTo15th++
  endwhile
  date15Prev_YYYYMMDD = date_YYYYMMDD


; Work forward until we reach the next mid-month.

  dayOfMonth = FIX(targetDate_DD)
  daysFwdTo15th = 0
  date_Julian = targetDate_Julian
  date_YYYYMMDD = TargetDate_YYYYMMDD
  while (dayOfMonth ne 15) do begin
      date_Julian = date_Julian + 1.0D
      date_YYYYMMDD = STRMID(JULIAN_TO_YYYYMMDDHH(date_Julian), 0, 8)
      dayOfMonth = FIX(STRMID(date_YYYYMMDD, 6, 2))
      daysFwdTo15th++
  endwhile
  date15Next_YYYYMMDD = date_YYYYMMDD

; Override results for late April and early October.

  if ((targetDate_MM eq '04') and (FIX(targetDate_DD) gt 15)) then begin
      daysBackTo15th = 0
      daysFwdTo15th = 0
  endif
  if ((targetDate_MM eq '10') and (FIX(targetDate_DD) lt 15)) then begin
      daysBackTo15th = 0
      daysFwdTo15th = 0
  endif
  if ((FIX(targetDate_MM) ge 5) and (FIX(targetDate_MM) le 9)) then begin
      daysBackTo15th = 0
      daysFwdTo15th = 0
      SLRMonth = 'Summer'
  endif

;  USR_MSG, 'Adjacent mid-month dates: ' + date15Prev_YYYYMMDD + ', ' + $
;           date15Next_YYYYMMDD
;  USR_MSG, 'Days back/forward: ' + STRCRA(daysBackTo15th) + ', ' + $
;           STRCRA(daysFwdTo15th)

  if ((daysBackTo15th eq 0) and (daysFwdTo15th ne 0)) then begin
      ERR_MSG, 'PROGRAMMING ERROR #1'
      RETURN
  endif

  if ((daysBackTo15th ne 0) and (daysFwdTo15th eq 0)) then begin
      ERR_MSG, 'PROGRAMMING ERROR #2'
      RETURN
  endif

;  Apr15_Julian = YYYYMMDDHH_TO_JULIAN(targetDate_YYYY + '050112')
;  Oct15_Julian = YYYYMMDDHH_TO_JULIAN(targetDate_YYYY + '100112')

  if (daysBackTo15th eq 0) then begin

      
;     Get SLR data for the current month. Since the current day is the
;     15th, this data will be used unmodified.

      if NOT(ISA(SLRMonth)) then $
          SLRMonth = MONTH_NAME(FIX(targetDate_MM))

;GF
      SLRYear = FIX(STRMID(TargetDate_YYYYMMDD, 0, 4))
      if (SLRYear lt 2019) then $
          yearRange = '1988_to_2017' $
      else $
          yearRange = STRING(SLRYear - 30, FORMAT = '(I4.4)') + '_to_' + $
                      STRING(SLRYear - 1, FORMAT = '(I4.4)')

      SLRFile = 'GHCND_SLR_clim_CONUS_' + SLRMonth + '_' + yearRange + $
                '_450_arc_sec.nc'
;GF
      ;PRINT, 'Using 1.0 x ' + SLRFile

      if NOT(FILE_TEST(SLRDir + '/' + SLRFile)) then begin
          ERR_MSG, 'SLR climatology file ' + $
                   SLRDir + '/' + SLRFile + ' not found.'
          RETURN
      endif

;      USR_MSG, 'Reading SLR data from ' + SLRDir + '/' + SLRFile

      GET_LONLAT_NETCDF_DATA, SLRDir, SLRFile, $
                              SLRGridInfo, $
                              SLRGrid_, $
                              UNITS_EXPECTED = 'dimensionless', $
                              NO_DATA_VALUE = ndvSLR

      if NOT(ISA(SLRGrid_)) then begin
          ERR_MSG, 'Failed to read SLR data in ' + $
                   SLRDir + '/' + SLRFile + '.'
          RETURN
      endif

      boundsOkay = 1

      if KEYWORD_SET(Pad) then begin


;         Calculate padding for requested bounds.

          padLeft = (SLRGridInfo.minLon - minLonOut) / SLRGridInfo.lonRes
          if (padLeft gt 1.0D-8) then begin
              if (ABS(DOUBLE(ROUND(padLeft)) - padLeft) gt 1.0D-8) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' minimum longitude padding incompatible with' + $
                           ' requested bounds.'
                  boundsOkay = 0
              endif
          endif
          padLeft = ROUND(padLeft) > 0L

          padRight = (maxLonOut - SLRGridInfo.maxLon) / SLRGridInfo.lonRes
          if (padRight gt 1.0D-8) then begin
              if (ABS(DOUBLE(ROUND(padRight)) - padRight) gt 1.0D-8) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' maximum longitude padding incompatible with' + $
                           ' requested bounds.'
                  boundsOkay = 0
              endif
          endif
          padRight = ROUND(padRight) > 0L

          padBottom = (SLRGridInfo.minLat - minLatOut) / SLRGridInfo.latRes
          if (padBottom gt 1.0D-8) then begin
              if (ABS(DOUBLE(ROUND(padBottom)) - padBottom) gt 1.0D-8) $
              then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' minimum latitude padding incompatible with' + $
                           ' requested bounds.'
                  boundsOkay = 0
              endif
          endif
          padBottom = ROUND(padBottom) > 0L

          padTop = (maxLatOut - SLRGridInfo.maxLat) / SLRGridInfo.latRes
          if (padTop gt 1.0D-8) then begin
              if (ABS(DOUBLE(ROUND(padTop)) - padTop) gt 1.0D-8) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' maximum latitude padding incompatible with' + $
                           ' requested bounds.'
                  boundsOkay = 0
              endif
          endif
          padTop = ROUND(padTop) > 0L

      endif else begin

          padLeft = 0L
          padRight = 0L
          padBottom = 0L
          padTop = 0L


;         Check requested bounds against data limits.

          if (minLonOut lt SLRGridInfo.minLon) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' minimum longitude incompatible with requested bounds.'
              boundsOkay = 0
          endif

          if (maxLonOut gt SLRGridInfo.maxLon) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' maximum longitude incompatible with requested bounds.'
              boundsOkay = 0
          endif

          if (minLatOut lt SLRGridInfo.minLat) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' minimum latitude incompatible with requested bounds.'
              boundsOkay = 0
          endif

          if (maxLatOut gt SLRGridInfo.maxLat) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' maximum latitude incompatible with requested bounds.'
              boundsOkay = 0
          endif

      endelse

      if NOT(boundsOkay) then RETURN


;     Adjust size and bounds to accommodate padding.

      SLRNumLon = SLRGridInfo.numLon + padLeft + padRight
      SLRNumLat = SLRGridInfo.numLat + padBottom + padTop
      SLRMinLon = SLRGridInfo.minLon - padLeft * SLRGridInfo.lonRes
      SLRMaxLon = SLRGridInfo.maxLon + padRight * SLRGridInfo.lonRes
      SLRMinLat = SLRGridInfo.minLat - padBottom * SLRGridInfo.latRes
      SLRMaxLat = SLRGridInfo.maxLat + padTop * SLRGridInfo.latRes


;     Perform padding if necessary.

      newSLRGrid = MAKE_ARRAY(SLRNumLon, SLRNumLat, VALUE = ndvSLR)
      newSLRGrid[padLeft:padLeft + SLRGridInfo.numLon - 1, $
                 padBottom:padBottom + SLRGridInfo.numLat - 1] = $
          SLRGrid_
      SLRGrid_ = newSLRGrid
      newSLRGrid = !NULL


;     Remove no-data values.

      if KEYWORD_SET(RemoveNdv) then $
          REPLACE_NDV_WITH_NEIGHBORHOOD_AVERAGE, $
          SLRGrid_, $
          ndvSLR, $
          SLRMinLon, SLRMaxLon, SLRGridInfo.lonRes, $
          SLRMinLat, SLRMaxLat, SLRGridInfo.latRes, $
          hoodMinMeters, hoodStepMeters, hoodMaxMeters, hoodMinNVal


;     Check for compatible input/output resolutions.

      xResFactor = SLRGridInfo.lonRes / xResOut
      yResFactor = SLRGridInfo.latRes / yResOut

      resOkay = 1

      nxSLROut = SLRNumLon * xResFactor
      nySLROut = SLRNumLat * yResFactor

      if (DOUBLE(ROUND(nxSLROut)) ne nxSLROut) then begin
          ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                   ' longitudinal resolution incompatible with' + $
                   ' requested resolution.'
          resOkay = 0
      endif

      if (DOUBLE(ROUND(nySLROut)) ne nySLROut) then begin
          ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                   ' latitudinal resolution incompatible with' + $
                   ' requested resolution.'
          resOkay = 0
      endif

      if NOT(resOkay) then RETURN

      nxSLROut = ROUND(nxSLROut)
      nySLROut = ROUND(nySLROut)


;     Resample SLR data, taking care to preserve no-data values.

      flag = CONGRID(FLOAT(SLRGrid_ ne ndvSLR), nxSLROut, nySLROut, /INTERP)
      SLRGrid_ = CONGRID(SLRGrid_, nxSLROut, nySLROut, /INTERP)
      ind = WHERE(flag lt 1.0, count)
      if (count gt 0) then SLRGrid_[ind] = Ndv

      if ((minLonOut gt SLRMinLon) or $
          (maxLonOut lt SLRMaxLon) or $
          (minLatOut gt SLRMinLat) or $
          (maxLatOut lt SLRMaxLat)) then begin


;         Subgrid SLR data to match requested bounds.

          left = ((minLonOut - SLRMinLon) / xResOut)
          if (ABS(DOUBLE(ROUND(left)) - left) gt 1.0D-8) then STOP ; PROG
          left = ROUND(left)

          right = ((SLRMaxLon - maxLonOut) / xResOut)
          if (ABS(DOUBLE(ROUND(right)) - right) gt 1.0D-8) then STOP ; PROG
          right = ROUND(right)

          bottom = ((minLatOut - SLRMinLat) / yResOut)
          if (ABS(DOUBLE(ROUND(bottom)) - bottom) gt 1.0D-8) then STOP ; PROG
          bottom = ROUND(bottom)

          top = ((SLRMaxLat - maxLatOut) / yResOut)
          if (ABS(DOUBLE(ROUND(top)) - top) gt 1.0D-8) then STOP ; PROG
          top = ROUND(top)

          SLRGrid_ = SLRGrid_[left:nxSLROut - right - 1L, $
                              bottom:nySLROut - top - 1L]

          nxSLROut = nxSLROut - left - right
          nySLROut = nySLROut - bottom - top

          if (nxSLROut ne nxOut) then STOP ; PROG
          if (nySLROut ne nyOut) then STOP ; PROG

      endif

  endif else begin


;     Perform a weighted average of SLR data for middle of the
;     previous and next months.

      SLRMonth1 = MONTH_NAME(FIX(STRMID(date15Prev_YYYYMMDD, 4, 2)))

;GF
      SLRYear = FIX(STRMID(date15Prev_YYYYMMDD, 0, 4))
      if (SLRYear lt 2019) then $
          yearRange = '1988_to_2017' $
      else $
          yearRange = STRING(SLRYear - 30, FORMAT = '(I4.4)') + '_to_' + $
                      STRING(SLRYear - 1, FORMAT = '(I4.4)')

      SLRWeight1 = FLOAT(daysFwdTo15th) / $
                   FLOAT(daysFwdTo15th + daysBackTo15th)

      SLRFile = 'GHCND_SLR_clim_CONUS_' + SLRMonth1 + '_' + yearRange + $
                '_450_arc_sec.nc'
;GF
      ;PRINT, 'Using ' + STRCRA(SLRWeight1) + ' x ' + SLRFile

      if NOT(FILE_TEST(SLRDir + '/' + SLRFile)) then begin

          ERR_MSG, 'SLR climatology file ' + $
                   SLRDir + '/' + SLRFile + ' not found.'
          SLRWeight1 = 0.0

      endif else begin

          GET_LONLAT_NETCDF_DATA, SLRDir, SLRFile, $
                                  SLRGridInfo, $
                                  SLRGrid1, $
                                  UNITS_EXPECTED = 'dimensionless', $
                                  NO_DATA_VALUE = ndvSLR

          if NOT(ISA(SLRGrid1)) then begin
              ERR_MSG, 'Failed to read SLR data in ' + $
                       SLRDir + '/' + SLRFile + '.'
              RETURN
          endif

          boundsOkay = 1

          if KEYWORD_SET(Pad) then begin


;             Calculate padding for requested bounds.

              padLeft = (SLRGridInfo.minLon - minLonOut) / $
                        SLRGridInfo.lonRes
              if (padLeft gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padLeft)) - padLeft) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' minimum longitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padLeft = ROUND(padLeft) > 0L

              padRight = (maxLonOut - SLRGridInfo.maxLon) / $
                         SLRGridInfo.lonRes
              if (padRight gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padRight)) - padRight) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' maximum longitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padRight = ROUND(padRight) > 0L

              padBottom = (SLRGridInfo.minLat - minLatOut) / $
                          SLRGridInfo.latRes
              if (padBottom gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padBottom)) - padBottom) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' minimum latitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padBottom = ROUND(padBottom) > 0L

              padTop = (maxLatOut - SLRGridInfo.maxLat) / $
                       SLRGridInfo.latRes
              if (padTop gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padTop)) - padTop) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' maximum latitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padTop = ROUND(padTop) > 0L

          endif else begin

              padLeft = 0L
              padRight = 0L
              padBottom = 0L
              padTop = 0L


;             Check requested bounds against data limits.

              if (minLonOut lt SLRGridInfo.minLon) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' minimum longitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

              if (maxLonOut gt SLRGridInfo.maxLon) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' maximum longitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

              if (minLatOut lt SLRGridInfo.minLat) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' minimum latitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

              if (maxLatOut gt SLRGridInfo.maxLat) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' maximum latitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

          endelse

          if NOT(boundsOkay) then RETURN


;         Adjust size and bounds to accommodate padding.

          SLRNumLon = SLRGridInfo.numLon + padLeft + padRight
          SLRNumLat = SLRGridInfo.numLat + padBottom + padTop
          SLRMinLon = SLRGridInfo.minLon - padLeft * SLRGridInfo.lonRes
          SLRMaxLon = SLRGridInfo.maxLon + padRight * SLRGridInfo.lonRes
          SLRMinLat = SLRGridInfo.minLat - padBottom * SLRGridInfo.latRes
          SLRMaxLat = SLRGridInfo.maxLat + padTop * SLRGridInfo.latRes


;         Perform padding if necessary.

          newSLRGrid = MAKE_ARRAY(SLRNumLon, SLRNumLat, VALUE = ndvSLR)
          newSLRGrid[padLeft:padLeft + SLRGridInfo.numLon - 1, $
                     padBottom:padBottom + SLRGridInfo.numLat - 1] = $
              SLRGrid1
          SLRGrid1 = newSLRGrid
          newSLRGrid = !NULL


;         Remove no-data values.

          if KEYWORD_SET(RemoveNdv) then $
              REPLACE_NDV_WITH_NEIGHBORHOOD_AVERAGE, $
              SLRGrid1, $
              ndvSLR, $
              SLRMinLon, SLRMaxLon, SLRGridInfo.lonRes, $
              SLRMinLat, SLRMaxLat, SLRGridInfo.latRes, $
              hoodMinMeters, hoodStepMeters, hoodMaxMeters, hoodMinNVal


;         Check for compatible input/output resolutions.

          xResFactor = SLRGridInfo.lonRes / xResOut
          yResFactor = SLRGridInfo.latRes / yResOut

          resOkay = 1

          nxSLROut = SLRNumLon * xResFactor
          nySLROut = SLRNumLat * yResFactor

          if (DOUBLE(ROUND(nxSLROut)) ne nxSLROut) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' longitudinal resolution incompatible with' + $
                       ' requested resolution.'
              resOkay = 0
          endif

          if (DOUBLE(ROUND(nySLROut)) ne nySLROut) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' latitudinal resolution incompatible with' + $
                       ' requested resolution.'
              resOkay = 0
          endif

          if NOT(resOkay) then RETURN

          nxSLROut = ROUND(nxSLROut)
          nySLROut = ROUND(nySLROut)


;         Resample SLR data, taking care to preserve no-data values.

          flag = CONGRID(FLOAT(SLRGrid1 ne ndvSLR), nxSLROut, nySLROut, $
                         /INTERP)
          SLRGrid1 = CONGRID(SLRGrid1, nxSLROut, nySLROut, /INTERP)
          ind = WHERE(flag lt 1.0, count)
          if (count gt 0) then SLRGrid1[ind] = Ndv

          if ((minLonOut gt SLRMinLon) or $
              (maxLonOut lt SLRMaxLon) or $
              (minLatOut gt SLRMinLat) or $
              (maxLatOut lt SLRMaxLat)) then begin


;             Subgrid SLR data to match requested bounds.

              left = ((minLonOut - SLRMinLon) / xResOut)
              if (ABS(DOUBLE(ROUND(left)) - left) gt 1.0D-8) $
                then STOP         ; PROG
              left = ROUND(left)

              right = ((SLRMaxLon - maxLonOut) / xResOut)
              if (ABS(DOUBLE(ROUND(right)) - right) gt 1.0D-8) $
                then STOP         ; PROG
              right = ROUND(right)

              bottom = ((minLatOut - SLRMinLat) / yResOut)
              if (ABS(DOUBLE(ROUND(bottom)) - bottom) gt 1.0D-8) $
                then STOP         ; PROG
              bottom = ROUND(bottom)

              top = ((SLRMaxLat - maxLatOut) / yResOut)
              if (ABS(DOUBLE(ROUND(top)) - top) gt 1.0D-8) $
                then STOP         ; PROG
              top = ROUND(top)

              SLRGrid1 = SLRGrid1[left:nxSLROut - right - 1L, $
                                  bottom:nySLROut - top - 1L]

              nxSLROut = nxSLROut - left - right
              nySLROut = nySLROut - bottom - top

              if (nxSLROut ne nxOut) then STOP ; PROG
              if (nySLROut ne nyOut) then STOP ; PROG

          endif

      endelse

      SLRMonth2 = MONTH_NAME(FIX(STRMID(date15Next_YYYYMMDD, 4, 2)))

;GF
      SLRYear = FIX(STRMID(date15Next_YYYYMMDD, 0, 4))
      if (SLRYear lt 2019) then $
          yearRange = '1988_to_2017' $
      else $
          yearRange = STRING(SLRYear - 30, FORMAT = '(I4.4)') + '_to_' + $
                      STRING(SLRYear - 1, FORMAT = '(I4.4)')

      SLRWeight2 = FLOAT(daysBackTo15th) / $
                   FLOAT(daysFwdTo15th + daysBackTo15th)

      SLRFile = 'GHCND_SLR_clim_CONUS_' + SLRMonth2 + '_' + yearRange + $
                '_450_arc_sec.nc'
;GF
      ;PRINT, 'Using ' + STRCRA(SLRWeight2) + ' x ' + SLRFile

      if NOT(FILE_TEST(SLRDir + '/' + SLRFile)) then begin

          ERR_MSG, 'SLR climatology file ' + $
                   SLRDir + '/' + SLRFile + ' not found.'
          SLRWeight2 = 0.0

      endif else begin

          GET_LONLAT_NETCDF_DATA, SLRDir, SLRFile, $
                                  SLRGridInfo, $
                                  SLRGrid2, $
                                  UNITS_EXPECTED = 'dimensionless', $
                                  NO_DATA_VALUE = ndvSLR_

          if NOT(ISA(SLRGrid2)) then begin
              ERR_MSG, 'Failed to read SLR data in ' + $
                       SLRDir + '/' + SLRFile + '.'
              RETURN
          endif

          if ISA(ndvSLR) then begin
              if (ndvSLR_ ne ndvSLR) then begin
                  ERR_MSG, 'Inconsistent no-data values in SLR data.'
                  RETURN
              endif
          endif else ndvSLR = ndvSLR_

          boundsOkay = 1

          if KEYWORD_SET(Pad) then begin


;             Calculate padding for requested bounds.

              padLeft = (SLRGridInfo.minLon - minLonOut) / $
                        SLRGridInfo.lonRes
              if (padLeft gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padLeft)) - padLeft) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' minimum longitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padLeft = ROUND(padLeft) > 0L

              padRight = (maxLonOut - SLRGridInfo.maxLon) / $
                         SLRGridInfo.lonRes
              if (padRight gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padRight)) - padRight) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' maximum longitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padRight = ROUND(padRight) > 0L

              padBottom = (SLRGridInfo.minLat - minLatOut) / $
                          SLRGridInfo.latRes
              if (padBottom gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padBottom)) - padBottom) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' minimum latitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padBottom = ROUND(padBottom) > 0L

              padTop = (maxLatOut - SLRGridInfo.maxLat) / $
                       SLRGridInfo.latRes
              if (padTop gt 1.0D-8) then begin
                  if (ABS(DOUBLE(ROUND(padTop)) - padTop) gt 1.0D-8) $
                    then begin
                      ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                               ' maximum latitude padding incompatible' + $
                               ' with requested bounds.'
                      boundsOkay = 0
                  endif
              endif
              padTop = ROUND(padTop) > 0L

          endif else begin

              padLeft = 0L
              padRight = 0L
              padBottom = 0L
              padTop = 0L


;             Check requested bounds against data limits.

              if (minLonOut lt SLRGridInfo.minLon) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' minimum longitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

              if (maxLonOut gt SLRGridInfo.maxLon) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' maximum longitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

              if (minLatOut lt SLRGridInfo.minLat) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' minimum latitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

              if (maxLatOut gt SLRGridInfo.maxLat) then begin
                  ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                           ' maximum latitude incompatible' + $
                           ' with requested bounds.'
                  boundsOkay = 0
              endif

          endelse

          if NOT(boundsOkay) then RETURN


;         Adjust size and bounds to accommodate padding.

          SLRNumLon = SLRGridInfo.numLon + padLeft + padRight
          SLRNumLat = SLRGridInfo.numLat + padBottom + padTop
          SLRMinLon = SLRGridInfo.minLon - padLeft * SLRGridInfo.lonRes
          SLRMaxLon = SLRGridInfo.maxLon + padRight * SLRGridInfo.lonRes
          SLRMinLat = SLRGridInfo.minLat - padBottom * SLRGridInfo.latRes
          SLRMaxLat = SLRGridInfo.maxLat + padTop * SLRGridInfo.latRes


;         Perform padding if necessary.

          newSLRGrid = MAKE_ARRAY(SLRNumLon, SLRNumLat, VALUE = ndvSLR)
          newSLRGrid[padLeft:padLeft + SLRGridInfo.numLon - 1, $
                     padBottom:padBottom + SLRGridInfo.numLat - 1] = $
              SLRGrid2
          SLRGrid2 = newSLRGrid
          newSLRGrid = !NULL


;         Remove no-data values.

          if KEYWORD_SET(RemoveNdv) then $
              REPLACE_NDV_WITH_NEIGHBORHOOD_AVERAGE, $
              SLRGrid2, $
              ndvSLR, $
              SLRMinLon, SLRMaxLon, SLRGridInfo.lonRes, $
              SLRMinLat, SLRMaxLat, SLRGridInfo.latRes, $
              hoodMinMeters, hoodStepMeters, hoodMaxMeters, hoodMinNVal


;         Check for compatible input/output resolutions.

          xResFactor = SLRGridInfo.lonRes / xResOut
          yResFactor = SLRGridInfo.latRes / yResOut

          resOkay = 1

          nxSLROut = SLRNumLon * xResFactor
          nySLROut = SLRNumLat * yResFactor

          if (DOUBLE(ROUND(nxSLROut)) ne nxSLROut) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' longitudinal resolution incompatible with' + $
                       ' requested resolution.'
              resOkay = 0
          endif

          if (DOUBLE(ROUND(nySLROut)) ne nySLROut) then begin
              ERR_MSG, 'SLR file ' + SLRDir + '/' + SLRFile + $
                       ' latitudinal resolution incompatible with' + $
                       ' requested resolution.'
              resOkay = 0
          endif

          if NOT(resOkay) then RETURN

          nxSLROut = ROUND(nxSLROut)
          nySLROut = ROUND(nySLROut)


;         Resample SLR data, taking care to preserve no-data values.

          flag = CONGRID(FLOAT(SLRGrid2 ne ndvSLR), nxSLROut, nySLROut, $
                         /INTERP)
          SLRGrid2 = CONGRID(SLRGrid2, nxSLROut, nySLROut, /INTERP)
          ind = WHERE(flag lt 1.0, count)
          if (count gt 0) then SLRGrid2[ind] = Ndv

          if ((minLonOut gt SLRMinLon) or $
              (maxLonOut lt SLRMaxLon) or $
              (minLatOut gt SLRMinLat) or $
              (maxLatOut lt SLRMaxLat)) then begin


;             Subgrid SLR data to match requested bounds.

              left = ((minLonOut - SLRMinLon) / xResOut)
              if (ABS(DOUBLE(ROUND(left)) - left) gt 1.0D-8) $
                then STOP         ; PROG
              left = ROUND(left)

              right = ((SLRMaxLon - maxLonOut) / xResOut)
              if (ABS(DOUBLE(ROUND(right)) - right) gt 1.0D-8) $
                then STOP         ; PROG
              right = ROUND(right)

              bottom = ((minLatOut - SLRMinLat) / yResOut)
              if (ABS(DOUBLE(ROUND(bottom)) - bottom) gt 1.0D-8) $
                then STOP         ; PROG
              bottom = ROUND(bottom)

              top = ((SLRMaxLat - maxLatOut) / yResOut)
              if (ABS(DOUBLE(ROUND(top)) - top) gt 1.0D-8) $
                then STOP         ; PROG
              top = ROUND(top)

              SLRGrid2 = SLRGrid2[left:nxSLROut - right - 1L, $
                                  bottom:nySLROut - top - 1L]

              nxSLROut = nxSLROut - left - right
              nySLROut = nySLROut - bottom - top

              if (nxSLROut ne nxOut) then STOP ; PROG
              if (nySLROut ne nyOut) then STOP ; PROG

          endif

      endelse


;     Combine SLRGrid1 and SLRGrid2.

      if ((SLRWeight1 + SLRWeight2) eq 0.0) then begin
          ERR_MSG, 'Insufficient SLR climatology data for estimate.'
          RETURN
      endif

      if (SLRWeight1 eq 0.0) then $
          SLRGrid1 = MAKE_ARRAY(nxOut, nyOut, /FLOAT, VALUE = Ndv)

      if (SLRWeight2 eq 0.0) then $
          SLRGrid2 = MAKE_ARRAY(nxOut, nyOut, /FLOAT, VALUE = Ndv)

      SLRGrid_ = MAKE_ARRAY(nxOut, nyOut, /FLOAT, VALUE = Ndv)

      ind = WHERE((SLRGrid1 ne Ndv) and (SLRGrid2 eq Ndv), count)
      if (count gt 0) then SLRGrid_[ind] = SLRGrid1[ind]
      ind = WHERE((SLRGrid1 eq Ndv) and (SLRGrid2 ne Ndv), count)
      if (count gt 0) then SLRGrid_[ind] = SLRGrid2[ind]
      ind = WHERE((SLRGrid1 ne Ndv) and (SLRGrid2 ne Ndv), count)
      if (count gt 0) then $
          SLRGrid_[ind] = SLRWeight1 * SLRGrid1[ind] + $
                          SLRWeight2 * SLRGrid2[ind]

      SLRGrid1 = !NULL
      SLRGrid2 = !NULL

  endelse

  SLRGrid = SLRGrid_
  SLRGrid_ = !NULL




  RETURN

end
