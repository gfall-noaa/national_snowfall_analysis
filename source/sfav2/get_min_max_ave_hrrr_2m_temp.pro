PRO GET_MIN_MAX_AVE_HRRR_2M_TEMP, $
    AnalysisEndDate_YYYYMMDDHH, $
    DurationHours, $
    TargetFcstHour, $
    MinSubFcstHour, $
    MaxSubFcstHour, $
    HRRRDir, $
    ScratchDir, $
    MinLonOut, $
    MaxLonOut, $
    MinLatOut, $
    MaxLatOut, $
    LonResOut, $
    LatResOut, $
    NoDataValue, $
    minTmpGrid, $
    maxTmpGrid, $
    aveTmpGrid, $
    perfect, $
    HRRR_GRID_PROJ_INFO = HRRRGridProjInfo, $
    MIN_FORECAST_HOUR_FOUND = minFcstHourFound, $
    MAX_FORECAST_HOUR_FOUND = maxFcstHourFound, $
    MAX_MISSING_HOURS = MaxMissingHours, $
    NUM_MISSING_HOURS = numMissingHours, $
    VERBOSE = Verbose, $
    NO_SAVE_FILE = No_save_file
;+
; Get hourly High Resolution Rapid Refresh (HRRR) 2-meter air
; temperatures (TMP) from GRIB files, determine gridded minimum,
; maximum, and mean values on the grid, and regrid/deproject the
; result to longitude/latitude coordinates with the designated
; geographic domain and resolution.
;
; There are different conventions for storing/archiving HRRR data that
; this procedure will need to handle. In the case of long-term
; archives, data are stored in directories such as:
;
;   /nwcdev/archive/HRRR_archive/{YYYY}/{MM}/{DD}
;
; In the case of GRIB files handled by operations, data are stored in
; a place like
;
;   /operations/misc/gisrs_incoming/HRRR
;
; In all cases we assume the GRIB files have names following one of
; these conventions:
;
;   {YY}{DOY}.hrrr.t{HH}z.wrfsfcf{FF}.grib2
;   hrrr.{YYYYMMDD}.t{HH}z.wrfsfcf{FF}.grib2
;
; If the desired TargetFcstHour is not found for any hour of the
; analysis period, a range of forecasts defined by the MinSubFcstHour
; and MaxSubFcstHour arguments are considered as alternatives.
; Typically the TargetFcstHour = 0 for instantaneous fields such as
; temperature, since that is an analysis result, generally more
; accurate than any forecast will ever be.
;
; :Params:
;
;     AnalysisEndDate_YYYYMMDDHH : in, required, type=STRING
;         End time of analysis period in UTC, in the form YYYYMMDDHH.
;     DurationHours : in, required, type=INT
;         Analysis duration in hours; e.g., 24 for min/max/ave grids
;         over a single day.
;     TargetFcstHour : in, required, type=INT
;         The forecast hour that is sought for all data.
;     MinSubFcstHour : in, required, type=INT
;         The minimum forecast hour to substitute in place of
;         TargetFcstHour, if data for TargetFcstHour is unavailable.
;     MaxSubFcstHour : in, required, type=INT
;         The maximum forecast hour to substitute in place of
;         TargetFcstHour, if data for TargetFcstHour is unavailable.
;     HRRRDir : in, required, type=STRING
;         The directory where High Resolution Rapid Refresh (HRRR)
;         data are stored.
;     ScratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure and the procedures it calls are stored.
;     MinLonOut : in, required, type=DOUBLE
;         The longitude of the westernmost edge of the westernmost
;         output grid column, in degrees.
;     MaxLonOut : in, required, type=DOUBLE
;         The longitude of the easternmost edge of the easternmost
;         output grid column, in degrees.
;     MinLatOut : in, required, type=DOUBLE
;         The latitude of the southernmost edge of the southernmost
;         output grid row, in degrees.
;     MaxLatOut : in, required, type=DOUBLE
;         The latitude of the northernmost edge of the northernmost
;         output grid row, in degrees.
;     LonResOut : in, required, type=DOUBLE
;         The longitudinal grid spacing in degrees.
;     LatResOut : in, required, type=DOUBLE
;         The latitudinal grid spacing in degrees.
;     NoDataValue : in, required, type=FLOAT
;         The value to use for missing/no-data on all grids. Missing
;         values for input data (e.g., 9.999e20 on GRIB data produced
;         at NCEP) are replaced by this value, and missing/no-data is
;         set to this value for all outputs.
;     minTmpGrid : out, type=FLTARR(nx x ny)
;         The minimum HRRR "2 m above ground" temperature across the
;         analysis period.
;     maxTmpGrid : out, type=FLTARR(nx x ny)
;         The maximum HRRR "2 m above ground" temperature across the
;         analysis period.
;     aveTmpGrid : out, type=FLTARR(nx x ny)
;         The average HRRR "2 m above ground" temperature across the
;         analysis period.
;     perfect : out, type=BYTE
;         A flag that indicates whether (1) or not (0) data was found
;         for the TargetFcstHour for every hour of the analysis period.
;
; :Keywords:
;
;     HRRR_GRID_PROJ_INFO : type=STRUCT
;         A named variable that will capture the structure describing
;         the HRRR (Lambert conformal) grid and coordinate system. If
;         this variable is undefined, it will be defined. If it is
;         already defined, it will be verified against the contents of
;         all input GRIB2 files. Note that the dimensions of the HRRR
;         grid defined by this structure will not match those of the
;         output grids, which are on a geographic (longitude/latitude)
;         grid.
;         Structure tags:
;
;         lonV (type=DOUBLE):
;         The orientation longitude, degrees.
;
;         latD (type=DOUBLE):
;         The latitude where the grid spacing is defined, degrees.
;
;         latSec1 (type=DOUBLE):
;         The first standard parallel for the projection, degrees.
;
;         latSec2 (type=DOUBLE):
;         The second standard parallel for the projection, degrees.
;
;         eRadM (type=DOUBLE):
;         The radius of the spherical earth in the projection, meters.
;
;         lat00 (type=DOUBLE):
;         The lower left grid cell center latitude, degrees.
;
;         lon00 (type=DOUBLE):
;         The lower left grid cell center longitude, degrees.
;
;         nCols (type=LONG):
;         The number of columns in the GRIB record.
;
;         nRows (type=LONG):
;         The number of rows in the GRIB record.
;
;         dx (type=DOUBLE):
;         The grid spacing in x, meters.
;
;         dy (type=DOUBLE):
;         The grid spacing in y, meters.
;
;     MIN_FORECAST_HOUR_FOUND : out, type=INT
;         Set this to a named variable in which the minimum forecast
;         hour contributing to the accumulation is returned.
;
;     MAX_FORECAST_HOUR_FOUND : out, type=INT
;         Set this to a named variable in which the maximum forecast
;         hour contributing to the accumulation is returned.
;
;     MAX_MISSING_HOURS : in, type=INT
;         The maximum number of hours for which missing data will be
;         tolerated. Default value is 0.
;
;     NUM_MISSING_HOURS : out, type=INT
;         Set this to a named variable in which the number of hours
;         missing from the min/max/ave calculation is returned.
;
;     VERBOSE : in, type=BOOLEAN
;         Activates the "verbose" option, causing this procedure to
;         produce some extra output text.
;
;     NO_SAVE_FILE : in, type=BOOLEAN
;         Deactivates the default behavior of this procedure, which
;         stores a version of its results in the ScratchDir as an IDL
;         save file, and reads its data from a save file if one is
;         found.
;-
  COMMON info, Message ; used by USR_MSG and ERR_MSG

;+
; The best way to check for the success of this procedure is to do
; "if (NOT(ISA(minTmpGrid)) or NOT(ISA(maxTmpGrid)) or
; NOT(ISA(aveTmpGrid))) then STOP" or something similar in the
; caller, since all will be returned as !NULL if this procedure is
; unable to get data.
;-
  minTmpGrid = !NULL
  maxTmpGrid = !NULL
  aveTmpGrid = !NULL
  perfect = 0B

;+
; Error handler for anything the main procedure code misses. Example:
; RESTORE encounters a file that was truncated because a disk filled.
; Comment this section out for debugging.
;-
  CATCH, errorStatus
  if (errorStatus ne 0) then begin
      ERR_MSG, !Error_State.Msg
      RETURN
  endif

;+
; Check arguments for correct type and valid contents.
;-
  if NOT(ISA(AnalysisEndDate_YYYYMMDDHH, 'STRING')) then begin
      ERR_MSG, 'Analysis end date/time argument ' + $
               'must be a STRING.'
      RETURN
  endif
  if (STRLEN(AnalysisEndDate_YYYYMMDDHH) ne 10) then begin
      ERR_MSG, 'Invalid analysis end date/time "' + $
               AnalysisEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, 10 digits).'
      RETURN
  endif
  if NOT(STREGEX(AnalysisEndDate_YYYYMMDDHH, '[0-9]{10}', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Invalid analysis end date/time "' + $
               AnalysisEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, all numeric).'
      RETURN
  endif

  if (DurationHours lt 0) then begin
      ERR_MSG, 'Duration must be a positive integer number of hours.'
      RETURN
  endif

  if ((TargetFcstHour lt 0) or $
      (MinSubFcstHour lt 0) or $
      (MaxSubFcstHour lt 0)) then begin
      ERR_MSG, 'All forecast hour options must be nonnegative.'
      RETURN
  endif

  if (MinSubFcstHour gt MaxSubFcstHour) then begin
      ERR_MSG, 'Minimum substitute forecast hour may not be larger than ' + $
               'maximum substitute forecast hour.'
      RETURN
  endif

  if NOT(ISA(HRRRDir, 'STRING')) then begin
      ERR_MSG, 'Location of HRRR archive must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(HRRRDir, /DIRECTORY)) then begin
      ERR_MSG, 'HRRR archive directory "' + HRRRDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(HRRRDir, /READ)) then begin
      ERR_MSG, 'HRRR archive directory "' + HRRRDir + '" not readable.'
      RETURN
  endif

  if NOT(ISA(ScratchDir, 'STRING')) then begin
      ERR_MSG, 'Location of scratch directory must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /DIRECTORY)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /READ)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not readable.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /WRITE)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not writeable.'
      RETURN
  endif

  if NOT(ISA(MinLonOut, 'DOUBLE')) then $
      minLonOut_ = DOUBLE(MinLonOut) $
  else $
      minLonOut_ = MinLonOut

  if NOT(ISA(MaxLonOut, 'DOUBLE')) then $
      maxLonOut_ = DOUBLE(MaxLonOut) $
  else $
      maxLonOut_ = MaxLonOut

  if NOT(ISA(MinLatOut, 'DOUBLE')) then $
      minLatOut_ = DOUBLE(MinLatOut) $
  else $
      minLatOut_ = MinLatOut

  if NOT(ISA(MaxLatOut, 'DOUBLE')) then $
      maxLatOut_ = DOUBLE(MaxLatOut) $
  else $
      maxLatOut_ = MaxLatOut

  if NOT(ISA(lonResOut, 'DOUBLE')) then $
      lonResOut_ = DOUBLE(LonResOut) $
  else $
      lonResOut_ = LonResOut

  if NOT(ISA(latResOut, 'DOUBLE')) then $
      latResOut_ = DOUBLE(LatResOut) $
  else $
      latResOut_ = LatResOut

  nColsOut_ = ROUND((maxLonOut_ - minLonOut_) / lonResOut_)
  nRowsOut_ = ROUND((maxLatOut_ - minLatOut_) / latResOut_)

  xErr = ABS(nColsOut_ * lonResOut_ - (maxLonOut_ - minLonOut_))
  if (xERR gt 1.0D-8) then begin
      ERR_MSG, 'Inconsistent longitudinal domain/resolution.'
      RETURN
  endif
  yErr = ABS(nRowsOut_ * latResOut_ - (maxLatOut_ - minLatOut_))
  if (yErr gt 1.0D-8) then begin
      ERR_MSG, 'Inconsistent latitudinal domain/resolution.'
      RETURN
  endif

  if NOT(ISA(NoDataValue, 'FLOAT')) then $
      ERR_MSG, 'WARNING: no-data value should be a floating point value.'

  if NOT(KEYWORD_SET(MaxMissingHours)) then MaxMissingHours = 0

  if (MaxMissingHours lt 0) then begin
      ERR_MSG, 'Maximum bad/missing hours must be a nonnegative integer' + $
               'number of hours.'
      RETURN
  endif

  if (MaxMissingHours ge DurationHours) then begin
      ERR_MSG, 'Maximum bad/missing hours must be less than the duration.'
      RETURN
  endif

  numMissingHours = 0

  if KEYWORD_SET(HRRRGridProjInfo) then begin

;+
;     Verify the HRRRGridProjInfo structure.
;-
      sizeHRRRGridProjInfo = SIZE(HRRRGridProjInfo)
      if (sizeHRRRGridProjInfo[0] ne 1) then begin
          ERR_MSG, 'HRRR_GRID_PROJ_INFO structure mismatch (non-scalar).'
          RETURN
      endif

      if ((sizeHRRRGridProjInfo[1] ne 1) or $
          (sizeHRRRGridProjInfo[2] ne 8)) then begin
          ERR_MSG, 'HRRR_GRID_PROJ_INFO structure mismatch ' + $
                   '(not a structure).'
          RETURN
      endif

      sizeHRRRGridProjInfo = !NULL

      structOK = 1

      tagNames = TAG_NAMES(HRRRGridProjInfo)
      ind = WHERE(tagNames eq 'LONV', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lonV" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LATD', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latD" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LATSEC1', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latSec1" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LATSEC2', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latSec2" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'ERADM', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "eRadM" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LAT00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lat00" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'LON00', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lon00" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'NCOLS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nCols" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'NROWS', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "nRows" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'DX', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dx" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      ind = WHERE(tagNames eq 'DY', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "dy" tag in HRRR_GRID_PROJ_INFO.'
          structOK = 0
      endif

      if structOK then begin

          if NOT(ISA(HRRRGridProjInfo.lonV, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"lonV".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.latD, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"latD".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.latSec1, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"latSec1".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.latSec2, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"latSec2".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.eRadM, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"eRadM".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.lat00, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"lat00".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.lon00, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"lon00".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.nCols, 'LONG')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing LONG element ' + $
                       '"nCols".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.nRows, 'LONG')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing LONG element ' + $
                       '"nRows".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.dx, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"dx".'
              structOK = 0
          endif

          if NOT(ISA(HRRRGridProjInfo.dy, 'DOUBLE')) then begin
              ERR_MSG, 'HRRR_GRID_PROJ_INFO missing DOUBLE element ' + $
                       '"dy".'
              structOK = 0
          endif

      endif

      if NOT(structOK) then begin

          ERR_MSG, 'Unexpected HRRR_GRID_PROJ_INFO structure definition.'
          RETURN

      endif

      structOK = !NULL

  endif

  savFile = 'HRRR_LONLAT_MIN_MAX_AVE_TMP' + $
            '_f' + STRING(targetFcstHour, FORMAT = '(I2.2)') + $
            '_' + STRCRA(durationHours) + 'h' + $
            '_ending_' + AnalysisEndDate_YYYYMMDDHH + '.sav'

  if (NOT(KEYWORD_SET(No_save_file)) and $
      FILE_TEST(ScratchDir + '/' + savFile)) then begin

;+
;     Get data from cache file rather than reading HRRR data
;     directly.
;-
      if KEYWORD_SET(Verbose) then $
          USR_MSG, 'Reading ' + ScratchDir + '/' + savFile

;+
;     Rename original output grid parameters. Restoring the cache
;     fill will probably replace them.
;-
      minLonOut__ = TEMPORARY(minLonOut_)
      maxLonOut__ = TEMPORARY(maxLonOut_)
      minLatOut__ = TEMPORARY(minLatOut_)
      maxLatOut__ = TEMPORARY(maxLatOut_)
      lonResOut__ = TEMPORARY(lonResOut_)
      latResOut__ = TEMPORARY(latResOut_)
      nColsOut__ = TEMPORARY(nColsOut_)
      nRowsOut__ = TEMPORARY(nRowsOut_)

      RESTORE, ScratchDir + '/' + savFile

;+
;     Verify the contents of the save file.
;-
      if NOT(ISA(minTmpGrid)) then begin
          ERR_MSG, 'No "minTmpGrid" variable in ' + $
                   ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      gridSize = SIZE(minTmpGrid)
      if (gridSize[0] ne 2) then begin
          ERR_MSG, '"minTmpGrid" in ' + ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

;+
;     Only compare grid dimensions against each other, not what is
;     expected via nColsOut__ and nRowsOut__.
;-
      nCols = gridSize[1]
      nRows = gridSize[2]

      if NOT(ISA(maxTmpGrid)) then begin
          ERR_MSG, 'No "maxTmpGrid" variable in ' + $
                   ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      gridSize = SIZE(maxTmpGrid)
      if (gridSize[0] ne 2) then begin
          ERR_MSG, '"maxTmpGrid" in ' + ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (gridSize[1] ne nCols) then begin
          ERR_MSG, '"maxTmpGrid" column dimension (' + $
                   STRCRA(gridSize[1]) + ') ' + $
                   'does not match that of "minTmpGrid" (' + $
                   STRCRA(nCols) + ').'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (gridSize[2] ne nRows) then begin
          ERR_MSG, '"maxTmpGrid" row dimension (' + $
                   STRCRA(gridSize[2]) + ') ' + $
                   'does not match that of "minTmpGrid (' + $
                   STRCRA(nRows) + ').'
          aveTmpGrid = !NULL
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          RETURN
      endif

      if NOT(ISA(aveTmpGrid)) then begin
          ERR_MSG, 'No "aveTmpGrid" variable in ' + $
                   ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      gridSize = SIZE(aveTmpGrid)
      if (gridSize[0] ne 2) then begin
          ERR_MSG, '"aveTmpGrid" in ' + ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (gridSize[1] ne nCols) then begin
          ERR_MSG, '"aveTmpGrid" column dimension (' + $
                   STRCRA(gridSize[1]) + ') ' + $
                   'does not match that of "minTmpGrid" (' + $
                   STRCRA(nCols) + ').'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (gridSize[2] ne nRows) then begin
          ERR_MSG, '"aveTmpGrid" row dimension (' + $
                   STRCRA(gridSize[2]) + ') ' + $
                   'does not match that of "minTmpGrid" (' + $
                   STRCRA(nRows) + ').'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      gridSize = !NULL

      if NOT(ISA(ndv_)) then begin
          ERR_MSG, 'Missing "ndv_" variable in ' + $
                   ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

;+
;     When checking grid bounds, only make sure that the requested
;     grid bounds lie within the grid bounds from the save file. If
;     necessary the grids from the save file will be subsetted later.
;-
      if NOT(ISA(minLonOut_)) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' missing "minLonOut_" variable.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (minLonOut_ gt minLonOut__) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' domain mismatch ("minLonOut_").'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if NOT(ISA(maxLonOut_)) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' missing "maxLonOut_" variable.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (maxLonOut_ lt maxLonOut__) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' domain mismatch ("maxLonOut_").'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if NOT(ISA(minLatOut_)) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' missing "minLatOut_" variable.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (minLatOut_ gt minLatOut__) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' domain mismatch ("minLatOut_").'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if NOT(ISA(maxLatOut_)) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' missing "maxLatOut_" variable.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (maxLatOut__ lt maxLatOut_) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' domain mismatch ("maxLatOut_").'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if NOT(ISA(lonResOut_)) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' missing "lonResOut_" variable.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (lonResOut_ ne lonResOut__) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' "lonResOut_" variable mismatch.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if NOT(ISA(latResOut_)) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' missing "latResOut_" variable.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if (latResOut_ ne latResOut__) then begin
          ERR_MSG, 'Cache file ' + ScratchDir + '/' + savFile + $
                   ' "latResOut_" variable mismatch.'
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

;+
;     Verify that the grids from the save file are internally
;     consistent with their stated domain/resolution.
;-
      nColsOut_ = ROUND((maxLonOut_ - minLonOut_) / lonResOut_)
      xErr = ABS(nColsOut_ * lonResOut_ - (maxLonOut_ - minLonOut_))
      if (xERR gt 1.0D-8) then begin
          ERR_MSG, 'Inconsistent longitudinal domain/resolution in ' + $
                   'cache file ' + ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif
      if (nColsOut_ ne nCols) then begin
          ERR_MSG, 'Longitudinal domain size and grid size mismatch in ' + $
                   'cache file ' + ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      nRowsOut_ = ROUND((maxLatOut_ - minLatOut_) / latResOut_)
      yErr = ABS(nRowsOut_ * latResOut_ - (maxLatOut_ - minLatOut_))
      if (yErr gt 1.0D-8) then begin
          ERR_MSG, 'Inconsistent latitudinal domain/resolution in ' + $
          'cache file ' + ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif
      if (nRowsOut_ ne nRows) then begin
          ERR_MSG, 'Longitudinal domain size and grid size mismatch in ' + $
                   'cache file ' + ScratchDir + '/' + savFile
          minTmpGrid = !NULL
          maxTmpGrid = !NULL
          aveTmpGrid = !NULL
          RETURN
      endif

      if ((minLonOut__ ne minLonOut_) or $
          (maxLonOut__ ne maxLonOut_) or $
          (minLatOut__ ne minLatOut_) or $
          (maxLatOut__ ne maxLatOut_)) then begin

;+
;         Get subgrids to match requested bounds. Note that the
;         domains were tested for compatibility (overlap) already.
;-
          numColsLeft = (minLonOut__ - minLonOut_) / lonResOut_
          if (ABS(DOUBLE(ROUND(numColsLeft)) - numColsLeft) gt 1.0D-6) $
              then begin
              ERR_MSG, 'WARNING: requested minimum longitude ' + $
                       'requires a non-integer crop.'
          endif
          numColsLeft = ROUND(numColsLeft)

          numColsRight = (maxLonOut_ - maxLonOut__) / lonResOut_
          if (ABS(DOUBLE(ROUND(numColsRight)) - numColsRight) gt 1.0D-6) $
              then begin
              ERR_MSG, 'WARNING: requested maximum longitude ' + $
                       'requires a non-integer crop.'
          endif
          numColsRight = ROUND(numColsRight)

          numRowsBot = (minLatOut__ - minLatOut_) / latResout_
          if (ABS(DOUBLE(ROUND(numRowsBot)) - numRowsBot) gt 1.0D-6) $
              then begin
              ERR_MSG, 'WARNING: requested minimum latitude ' + $
                       'requires a non-integer crop.'
          endif
          numRowsBot = ROUND(numRowsBot)

          numRowsTop = (maxLatOut_ - maxLatOut__) / latResOut_
          if (ABS(DOUBLE(ROUND(numRowsTop)) - numRowsTop) gt 1.0D-6) $
              then begin
              ERR_MSG, 'WARNING: requested maximum latitude ' + $
                       'requires a non-integer crop.'
          endif
          numRowsTop = ROUND(numRowsTop)

          err = 0

          subgridCols = nColsOut_ - numColsLeft - numColsRight
          if (subgridCols lt 0) then begin
              ERR_MSG, 'Requested longitude bounds result in empty grid.'
              err = 1
          endif

          subgridRows = nRowsOut_ - numRowsBot - numRowsTop
          if (subgridRows lt 0) then begin
              ERR_MSG, 'Requested latitude bounds result in empty grid.'
              err = 1
          endif

          if (subgridCols ne nColsOut__) then STOP ; PROGRAMMING ERROR
          if (subgridRows ne nRowsOut__) then STOP ; PROGRAMMING ERROR

          if err then begin
              if NOT(LMGR(/RUNTIME)) then STOP else begin
                  RETURN
                  minTmpGrid = !NULL
                  maxTmpGrid = !NULL
                  aveTmpGrid = !NULL
              endelse
          endif

          minTmpGrid = minTmpGrid[numColsLeft: $
                                  nColsOut_ - numColsRight - 1L, $
                                  numRowsBot: $
                                  nRowsOut_ - numRowsTop - 1L]
          maxTmpGrid = maxTmpGrid[numColsLeft: $
                                  nColsOut_ - numColsRight - 1L, $
                                  numRowsBot: $
                                  nRowsOut_ - numRowsTop - 1L]
          aveTmpGrid = aveTmpGrid[numColsLeft: $
                                  nColsOut_ - numColsRight - 1L, $
                                  numRowsBot: $
                                  nRowsOut_ - numRowsTop - 1L]

      endif

;+
;     Verify the no-data value is consistent; modify if it is not.
;-
      if (ndv_ ne NoDataValue) then begin
          ERR_MSG, 'WARNING: value of "ndv_" variable in ' + $
                  ScratchDir + '/' + savFile + $
                  ' (' + STRCRA(ndv_) + ') differs from ' + $
                  ' argument "NoDataValue" ' + $
                  '(' + STRCRA(NoDataValue) + '). Will adapt.'
          ind = WHERE(aveTmpGrid eq ndv_, count)
          if (count gt 0) then aveTmpGrid[ind] = NoDataValue
          ind = WHERE(minTmpGrid eq ndv_, count)
          if (count gt 0) then minTmpGrid[ind] = NoDataValue
          ind = WHERE(maxTmpGrid eq ndv_, count)
          if (count gt 0) then maxTmpGrid[ind] = NoDataValue
          ind = !NULL
      endif

      perfect = 1B
      minFcstHourFound = TargetFcstHour ; save file would not have been
      maxFcstHourFound = TargetFcstHour ; made otherwise

      RETURN

  endif

;+
; Read HRRR data from GRIB file/s and regrid. This is really the
; beginning of the process if we do not have a SAVE file.
;-
  minTmpGridLC = !NULL
  maxTmpGridLC = !NULL
  aveTmpGridLC = !NULL

  GET_MIN_MAX_AVE_HRRR_LC_2M_TEMP, $
      AnalysisEndDate_YYYYMMDDHH, $
      DurationHours, $
      TargetFcstHour, $
      MinSubFcstHour, $
      MaxSubFcstHour, $
      HRRRDir, $
      ScratchDir, $
      NoDataValue, $
      minTmpGridLC, $
      maxTmpGridLC, $
      aveTmpGridLC, $
      perfect_, $
      HRRR_GRID_PROJ_INFO = HRRRGridProjInfo, $
      MIN_FORECAST_HOUR_FOUND = minFcstHourFound_, $
      MAX_FORECAST_HOUR_FOUND = maxFcstHourFound_, $
      MAX_MISSING_HOURS = MaxMissingHours, $
      NUM_MISSING_HOURS = numMissingHours, $
      VERBOSE = KEYWORD_SET(Verbose), $
      NO_SAVE_FILE = KEYWORD_SET(No_save_file)

  if (NOT(ISA(minTmpGridLC)) or $
      NOT(ISA(maxTmpGridLC)) or $
      NOT(ISA(aveTmpGridLC))) then begin
      ERR_MSG, 'Failed to get min/max/ave HRRR temperatures for ' + $
               STRCRA(DurationHours) + ' hours ending ' + $
               AnalysisEndDate_YYYYMMDDHH
      RETURN
  endif

;+
; Calculate rows and columns of input grid that define output grid
; relative to input grid.
;-
  lonAxis = minLonOut_ + (0.5D + DINDGEN(nColsOut_)) * lonResOut_
  latAxis = minLatOut_ + (0.5D + DINDGEN(nRowsOut_)) * latResOut_
  lonGrid = lonAxis # REPLICATE(1.0D, nRowsOut_)
  latGrid = REPLICATE(1.0D, nColsOut_) # latAxis

  LCC_GRIB2_TO_SNYDER, HRRRGridProjInfo.latSec1, $
                       HRRRGridProjInfo.latSec2, $
                       HRRRGridProjInfo.latD, $
                       HRRRGridProjInfo.lonV, $
                       HRRRGridProjInfo.lat00, $
                       HRRRGridProjInfo.lon00, $
                       HRRRGridProjInfo.eRadM, $
                       lonV_rad, $
                       nSny, $
                       FSny, $
                       rho0, $
                       x00, $
                       y00

  degToRad = !DPi / 180.0D
  rho = HRRRGridProjInfo.eRadM * FSny / $
        (TAN(!DPi / 4.0D + latGrid * degToRad / 2.0D))^nSny ; Snyder 15-1
  theta_rad = nSny * (lonGrid * degToRad - lonV_rad)
  x = rho * SIN(theta_rad)        ; x location on HRRR LC grid
  y = rho0 - rho * COS(theta_rad) ; y location on HRRR LC grid

  rho = !NULL
  theta_rad = !NULL

  iGrid_HRRR = (x - x00) / HRRRGridProjInfo.dx
  jGrid_HRRR = (y - y00) / HRRRGridProjInfo.dy

  x = !NULL
  y = !NULL

;+
; Perform regridding.
;-
  minTmpGrid_ = REGRID_BILIN(minTmpGridLC, $
                             iGrid_HRRR, $
                             jGrid_HRRR, $
                             NoDataValue)
  if NOT(ISA(minTmpGrid_)) then RETURN
  maxTmpGrid_ = REGRID_BILIN(maxTmpGridLC, $
                             iGrid_HRRR, $
                             jGrid_HRRR, $
                             NoDataValue)
  if NOT(ISA(maxTmpGrid_)) then RETURN
  aveTmpGrid_ = REGRID_BILIN(aveTmpGridLC, $
                             iGrid_HRRR, $
                             jGrid_HRRR, $
                             NoDataValue)
  if NOT(ISA(aveTmpGrid_)) then RETURN

  minTmpGrid = TEMPORARY(minTmpGrid_)
  maxTmpGrid = TEMPORARY(maxTmpGrid_)
  aveTmpGrid = TEMPORARY(aveTmpGrid_)

  perfect = TEMPORARY(perfect_)
  minFcstHourFound = TEMPORARY(minFcstHourFound_)
  maxFcstHourFound = TEMPORARY(maxFcstHourFound_)

  if (perfect and NOT(KEYWORD_SET(No_save_file))) then begin

;+
;     Create IDL save file.
;-
      ndv_ = NoDataValue

      SAVE, minTmpGrid, maxTmpGrid, aveTmpGrid, $
            minLonOut_, maxLonOut_, minLatOut_, maxLatOut_, $
            lonResOut_, latResOut_, $
            ndv_, $
            FILE = ScratchDir + '/' + savFile

      if KEYWORD_SET(Verbose) then $
          USR_MSG, 'Minimum, maximum, and average temperature ' + $
                   'lon/lat grids saved to ' + $
                   ScratchDir + '/' + savFile

  endif

  RETURN

end
