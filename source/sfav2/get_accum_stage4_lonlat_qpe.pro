PRO GET_ACCUM_STAGE4_LONLAT_QPE, $
    AccumEndDate_YYYYMMDDHH, $       ; end of accumulation
    DurationHours, $                 ; number of hours to aggregate
    St4Dir, $                        ; location of GRIB archive
    ScratchDir, $                    ; location for temp files
    MinLonOut, $
    MaxLonOut, $
    MinLatOut, $
    MaxLatOut, $
    LonResOut, $
    LatResOut, $
    NoDataValue, $
    accumQPEGrid, $
    HRAP_GRID_PROJ_INFO = HRAPGridProjInfo, $
    VERBOSE = Verbose
;+
; Get accumulated Stage IV quantitative precipitation estimates (QPE)
; from aggregated 6-hour QPE grids stored in GRIB files, and
; regrid/deproject the data to longitude/latitude coordinates with the
; designated geographic domain and resolution.
;
; :Params:
;
;     AccumEndDate_YYYYMMDDHH : in, required, type=STRING
;         End time of accumulation period in UTC, in the form
;         YYYYMMDDHH.
;     DurationHours : in, required, type=INT
;         Accumulation duration in hours; e.g., 24 for a day of
;         precipitation accumulation. Must be a multiple of 6.
;     St4Dir : in, required, type=STRING
;         The directory where Stage IV data are stored.
;     ScratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure and the procedures it calls are stored.
;     MinLonOut : in, required, type=DOUBLE
;         The longitude of the westernmost edge of the westernmost
;         output grid column, in degrees.
;     MaxLonOut : in, required, type=DOUBLE
;         The longitude of the easternmost edge of the easternmost
;         output grid column, in degrees.
;     MinLatOut : in, required, type=DOUBLE
;         The latitude of the southernmost edge of the southernmost
;         output grid row, in degrees.
;     MaxLatOut : in, required, type=DOUBLE
;         The latitude of the northernmost edge of the northernmost
;         output grid row, in degrees.
;     LonResOut : in, required, type=DOUBLE
;         The longitudinal grid spacing in degrees.
;     LatResOut : in, required, type=DOUBLE
;         The latitudinal grid spacing in degrees.
;     NoDataValue : in, required, type=FLOAT
;         The value to use for missing/no-data on all grids. Missing
;         values for input data (e.g., 9.999e20 on GRIB data produced
;         at NCEP) are replaced by this value, and missing/no-data is
;         set to this value for all outputs.
;     accumQPEGrid : out, type=FLTARR(nx x ny)
;         The aggregated and regridded Stage IV precipitation
;         estimate.
;
; :Keywords:
;
;     HRAP_GRID_PROJ_INFO : type=STRUCT
;         A named variable that will capture the structure describing
;         the HRAP (polar stereographic) grid and coordinate
;         system. If this variable is undefined, it will be
;         defined. If it is already defined, it will be verified
;         against the contents of the input GRIB file.
;         Structure tags:
;
;         lonV (type=DOUBLE):
;         The orientation longitude, degrees.
;
;         latD (type=DOUBLE):
;         The latitude where the grid spacing is defined, degrees.
;
;         eRadM (type=DOUBLE)
;         The radius of the spherical earth in the projection, meters.
;
;         lat00 (type=DOUBLE)
;         The lower left grid cell center latitude, degrees.
;
;         lon00 (type=DOUBLE):
;         The lower left grid cell center longitude, degrees.
;
;         nCols (type=LONG):
;         The number of columns in the GRIB record.
;
;         nRows (type=LONG):
;         The number of rows in the GRIB record.
;
;         dx (type=DOUBLE):
;         The grid spacing in x, meters.
;
;         dy (type=DOUBLE):
;         The grid spacing in y, meters.
;
;     VERBOSE : in, type=BOOLEAN
;         Activates the "verbose" option, causing this procedure to
;         produce some extra output text.
;-


  COMMON info, Message ; used by USR_MSG and ERR_MSG

;+
; The best way to check for the success of this procedure is to
; do "if NOT(ISA(accumQPEGrid)) then STOP" or something similar in the
; caller, since the grid will be returned as !NULL if this procedure
; is unable to get data.
;-
  accumQPEGrid = !NULL

;+
; Error handler for anything the main procedure code misses. Example:
; RESTORE encounters a file that was truncated because a disk filled.
; Comment this section out when debugging.
;-
  CATCH, errorStatus
  if (errorStatus ne 0) then begin
      ERR_MSG, !Error_State.Msg
      RETURN
  endif

;+
; Check arguments for correct type and valid contents.
;-
  if NOT(ISA(AccumEndDate_YYYYMMDDHH, 'STRING')) then begin
      ERR_MSG, 'Target accumulation end date/time argument must be a STRING.'
      RETURN
  endif

  if (STRLEN(AccumEndDate_YYYYMMDDHH) ne 10) then begin
      ERR_MSG, 'Invalid target accumulation end date/time "' + $
               AccumEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, 10 digits).'
      RETURN
  endif

  if NOT(STREGEX(AccumEndDate_YYYYMMDDHH, '[0-9]{10}', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Invalid target accumulation end date/time "' + $
               AccumEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, all numeric).'
      RETURN
  endif

  accumEndDate_Julian = YYYYMMDDHH_TO_JULIAN(AccumEndDate_YYYYMMDDHH)
  accumEndDate_YYYY = STRMID(AccumEndDate_YYYYMMDDHH, 0, 4)
  accumEndDate_MM = STRMID(AccumEndDate_YYYYMMDDHH, 4, 2)
  accumEndDate_DD = STRMID(AccumEndDate_YYYYMMDDHH, 6, 2)
  accumEndDate_HH = STRMID(AccumEndDate_YYYYMMDDHH, 8, 2)

  if (FIX(accumEndDate_HH) mod 6 ne 0) then begin
      ERR_MSG, 'Invalid accumulation end date/time "' + $
               AccumEndDate_YYYYMMDDHH + $
               '" (must end in "00", "06", "12", or "18").'
      RETURN
  endif

  if (DurationHours lt 1) then begin
      ERR_MSG, 'Duration must be a positive integer number of hours.'
      RETURN
  endif

;  if (DurationHours gt 999) then begin
;      ERR_MSG, 'Duration argument cannot exceed 999 hours.'
;      RETURN
;  endif

  if ((DurationHours mod 6) ne 0) then begin
      ERR_MSG, 'Duration argument must be a multiple of 6 (' + $
               STRCOMPRESS(DurationHours, /REMOVE_ALL) + ' provided).'
      RETURN
  endif

  if NOT(ISA(St4Dir, 'STRING')) then begin
      ERR_MSG, 'Location of Stage IV archive must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(St4Dir, /DIRECTORY)) then begin
      ERR_MSG, 'Stage IV archive directory "' + St4Dir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(St4Dir, /READ)) then begin
      ERR_MSG, 'Stage IV archive directory "' + St4Dir + '" not readable.'
      RETURN
  endif

  if NOT(ISA(ScratchDir, 'STRING')) then begin
      ERR_MSG, 'Location of scratch directory must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /DIRECTORY)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /READ)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not readable.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /WRITE)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not writeable.'
      RETURN
  endif

  if NOT(ISA(MinLonOut, 'DOUBLE')) then $
      minLonOut_ = DOUBLE(MinLonOut) $
  else $
      minLonOut_ = MinLonOut

  if NOT(ISA(MaxLonOut, 'DOUBLE')) then $
      maxLonOut_ = DOUBLE(MaxLonOut) $
  else $
      maxLonOut_ = MaxLonOut

  if NOT(ISA(MinLatOut, 'DOUBLE')) then $
      minLatOut_ = DOUBLE(MinLatOut) $
  else $
      minLatOut_ = MinLatOut

  if NOT(ISA(MaxLatOut, 'DOUBLE')) then $
      maxLatOut_ = DOUBLE(MaxLatOut) $
  else $
      maxLatOut_ = MaxLatOut

  if NOT(ISA(LonResOut, 'DOUBLE')) then $
      lonResOut_ = DOUBLE(LonResOut) $
  else $
      lonResOut_ = LonResOut

  if NOT(ISA(LatResOut, 'DOUBLE')) then $
      latResOut_ = DOUBLE(LatResOut) $
  else $
      latResOut_ = LatResOut

  nColsOut_ = ROUND((maxLonOut_ - minLonOut_) / lonResOut_)
  nRowsOut_ = ROUND((maxLatOut_ - minLatOut_) / latResOut_)

  xErr = ABS(nColsOut_ * lonResOut_ - (maxLonOut_ - minLonOut_))
  if (xERR gt 1.0D-8) then begin
      ERR_MSG, 'Inconsistent longitudinal domain/resolution.'
      RETURN
  endif
  yErr = ABS(nRowsOut_ * latResOut_ - (maxLatOut_ - minLatOut_))
  if (yErr gt 1.0D-8) then begin
      ERR_MSG, 'Inconsistent latitudinal domain/resolution.'
      RETURN
  endif

  if NOT(ISA(NoDataValue, 'FLOAT')) then $
      ERR_MSG, 'WARNING: no-data value should be a floating point value.'

;+
; Get accumulated Stage IV data on the HRAP grid.
;-
  GET_ACCUM_STAGE4_HRAP_QPE, AccumEndDate_YYYYMMDDHH, $
                             DurationHours, $
                             St4Dir, $
                             ScratchDir, $
                             NoDataValue, $
                             accumQPEHRAPGrid, $
                             HRAP_GRID_PROJ_INFO = HRAPGridProjInfo, $
                             VERBOSE = KEYWORD_SET(Verbose)

  if NOT(ISA(accumQPEHRAPGrid)) then begin
      if KEYWORD_SET(Verbose) then $
          ERR_MSG, 'Failed to get Stage IV precipitation for ' + $
                   STRCRA(DurationHours) + ' hours ending ' + $
                   AccumEndDate_YYYYMMDDHH
      RETURN
  endif

;+
; Calculate rows and columns (of the input grid) that the define the
; output grid cell centers relative to the input grid.
;-
  lonAxis = minLonOut_ + (0.5D + DINDGEN(nColsOut_)) * lonResOut_
  latAxis = minLatOut_ + (0.5D + DINDGEN(nRowsOut_)) * latResOut_
  lonGrid = lonAxis # REPLICATE(1.0D, nRowsOut_)
  latGrid = REPLICATE(1.0D, nColsOut_) # latAxis
  lonAxis = !NULL
  latAxis = !NULL

  degToRad = !DPi / 180.0D
  lonV_rad = HRAPGridProjInfo.lonV * degToRad
  latD_rad = HRAPGridProjInfo.latD * degToRad
  lat00_rad = HRAPGridProjInfo.lat00 * degToRad
  lon00_rad = HRAPGridProjInfo.lon00 * degToRad

  rho00 = HRAPGridProjInfo.eRadM * $
          (1.0D + SIN(latD_rad)) * $
          TAN(!DPi / 4.0D - lat00_rad / 2.0D)
  theta00 = lon00_rad - lonV_rad

  x00 = rho00 * SIN(theta00)
  y00 = -rho00 * COS(theta00)

  rho = HRAPGridProjInfo.eRadM * $
        (1.0D + SIN(latD_rad)) * $
        TAN(!DPi / 4.0D - latGrid * degToRad / 2.0D)
  theta_rad = lonGrid * degToRad - lonV_rad

  latGrid = !NULL
  lonGrid = !NULL

  x = rho * SIN(theta_rad)
  y = -rho * COS(theta_rad)

  rho = !NULL
  theta_rad = !NULL

  iGrid_HRAP = (x - x00) / HRAPGridProjInfo.dx
  jGrid_HRAP = (y - y00) / HRAPGridProjInfo.dy

  x = !NULL
  y = !NULL

  accumQPEGrid_ = REGRID_BILIN(accumQPEHRAPGrid, $
                               iGrid_HRAP, $
                               jGrid_HRAP, $
                               NoDataValue)
  if NOT(ISA(accumQPEGrid_)) then RETURN

  accumQPEGrid = TEMPORARY(accumQPEGrid_)

  RETURN

end
